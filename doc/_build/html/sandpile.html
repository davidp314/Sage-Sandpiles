<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to Sage Sandpiles’s documentation! &mdash; Sage Sandpiles v2.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Sage Sandpiles v2.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="">Sage Sandpiles v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-sage-sandpiles-s-documentation">
<h1>Welcome to Sage Sandpiles&#8217;s documentation!<a class="headerlink" href="#welcome-to-sage-sandpiles-s-documentation" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
</ul>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Sage Sandpiles is a package for calculations involving Dhar&#8217;s abelian sandpile
model (ASM) using the open-source mathematics software, Sage.  A brief
introduction to the ASM follows.  For a more thorough introduction, the papers
<em>Chip-Firing and Rotor-Routing on Directed Graphs</em> <a class="reference internal" href="#h">[H]</a>, by Holroyd et al. and
<em>Riemann-Roch and Abel-Jacobi Theory on a Finite Graph</em> by Baker and Norine
<a class="reference internal" href="#bn">[BN]</a> are recommended.</p>
<p>To describe the ASM, we start with a <em>sandpile graph</em>: a directed multigraph
<img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> with a vertex <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> that is accessible from every vertex (except
possible <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/>, itself).  By <em>multigraph</em>, we mean that each edge of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is
assigned a nonnegative integer weight.  To say <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> is <em>accessible</em> from some
vertex <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> means that there is a sequence of directed edges starting at <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> and
ending at <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/>.  We call <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> the <em>sink</em> of the sandpile graph, even though it might have outgoing edges, for reasons that will be made clear in a moment.</p>
<p>We denoted the vertices of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> by <img class="math" src="_images/math/12d58aa29201da09d8e620f8698e3a37547f6b4a.png" alt="V"/> and define <img class="math" src="_images/math/621960fbeaafa37a5da529bb563c2f822831dfe9.png" alt="\tilde{V} = V\setminus\{s\}"/>.</p>
<div class="section" id="configurations-and-divisors">
<h3>Configurations and divisors<a class="headerlink" href="#configurations-and-divisors" title="Permalink to this headline">¶</a></h3>
<p>A <em>configuration</em> on <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is an element of <img class="math" src="_images/math/608a64606d4382c71466d20d069649a35630be83.png" alt="\mathbb{N}\tilde{V}"/>, i.e., the
assignment of a nonnegative integer to each nonsink vertex.  We think of each
integer as a number of grains of sand being placed at the corresponding
vertex.  A <em>divisor</em> on <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is an element of <img class="math" src="_images/math/23b3d7fef9fd3952c6c5d6085438cc11f5861ac8.png" alt="\mathbb{Z}V"/>, i.e., an
element in the free abelian group on <em>all</em> of the vertices.  In the context of
divisors, it is sometimes useful to think of assigning dollars to each vertex,
with negative integers signifying a debt.</p>
</div>
<div class="section" id="stabilization">
<h3>Stabilization<a class="headerlink" href="#stabilization" title="Permalink to this headline">¶</a></h3>
<p>A configuration <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is <em>stable</em> at a vertex <img class="math" src="_images/math/565bd9d75e8d5f8d88b796ce727f8f5293c8ace3.png" alt="v\in\tilde{V}"/> if
<img class="math" src="_images/math/586b09e40fc93d6a1a99e4e92ca23106a88249ba.png" alt="c(v)&lt;\mbox{out-degree}(v)"/>, and <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> itself is stable if it is stable at each
nonsink vertex.  Otherwise, <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is <em>unstable</em>.  If <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is unstable at <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>, the vertex <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> can be <em>fired</em>
(<em>toppled</em>) by removing <img class="math" src="_images/math/92d94d6d663b4045f286ea18cb688748fe898137.png" alt="\mbox{out-degree}(v)"/> grains of sand from <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> and
adding grains of sand to the neighbors of sand, determined by the weights of
the edges leaving <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>.</p>
<p>Despite our best intentions, we sometimes consider firing a stable vertex,
resulting in a configuration with a &#8220;negative amount&#8221; of sand at that vertex.
We may also <em>reverse-firing</em> a vertex, absorbing sand from the vertex&#8217;s
neighbors.</p>
<p><strong>Example.</strong> Consider the graph:</p>
<div align="center" class="figure">
<img alt="_images/example1.png" src="_images/example1.png" />
<p class="caption"><img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/></p>
</div>
<p>All edges have weight <img class="math" src="_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1"/> except for the edge from vertex 1 to vertex 3,
which has weight <img class="math" src="_images/math/41c544263a265ff15498ee45f7392c5f86c6d151.png" alt="2"/>.  If we let <img class="math" src="_images/math/1ce9367186c98d2b7416f395bd2c8f1d839a437e.png" alt="c=(5,0,1)"/> with the indicated number of
grains of sand on vertices 1, 2, and 3, respectively, then only vertex 1,
whose out-degree is 4, is unstable.  Firing vertex 1 gives a new
configuration <img class="math" src="_images/math/00176f2f156fd53258ae5d810bd38fa65ae5f992.png" alt="c'=(1,1,3)"/>.  Here, <img class="math" src="_images/math/c7cab1a05e1e0c1d51a6a219d96577a16b7abf9d.png" alt="4"/> grains have left vertex 1.  One of
these has gone to the sink vertex (and forgotten), one has gone to vertex 1,
and two have gone to vertex 2, since the edge from 1 to 2 has weight 2.
Vertex 3 in the new configuration is now unstable.  The Sage code for this
example looks like this:</p>
<div class="highlight-python"><pre>Create the sandpile:

    sage: load sandpile.sage
    sage: g = {'sink':{},
               1:{'sink':1, 2:1, 3:2},
               2:{1:1, 3:1},
               3:{1:1, 2:1}}
    sage: S = Sandpile(g, 'sink')
    sage: S.show(edge_labels=true)  # to display the graph

Create the configuration:

    sage: c = Config(S, {1:5, 2:0, 3:1})
    sage: S.out_degree()
    {1: 4, 2: 2, 3: 2, 'sink': 0}

Fire vertex one:

   sage: c.fire_vertex(1,c)
   {1: 1, 2: 1, 3: 3}

The configuration is unchanged:

    sage: c
    {1: 5, 2: 0, 3: 1}

Repeatedly fire vertices until the configuration becomes stable:

    sage: c.stabilize()
    {1: 2, 2: 1, 3: 1}

Alternatives:

    sage: ~c             # shorthand for c.stabilize()
    {1: 2, 2: 1, 3: 1}
    sage: c.stabilize(with_firing_vector=true)
    [{1: 2, 2: 1, 3: 1}, {1: 2, 2: 2, 3: 3}]</pre>
</div>
<p>Since vertex 3 has become unstable after firing vertex 1, it can be fired,
which causes vertex 2 to become unstable, etc.  Repeated firings eventually
lead to a stable configuration.  The last line of the Sage code, above, is a
list, the first element of which is the resulting stable configuration,
<img class="math" src="_images/math/10978ea305daaed098c945078ee8484c78550419.png" alt="(2,1,1)"/>.  The second component records how many times each vertex fired in
the stabilization.</p>
<hr class="docutils" />
<p>Since the sink is accessible from each nonsink vertex and never fires, every
configuration will stabilize after a finite number of vertex-firings.  It is
not obvious, but the resulting stabilization is independent of the order in
which unstable vertices are fired.  Thus, each configuration stabilizes to a
unique stable configuration.</p>
</div>
<div class="section" id="laplacian">
<h3>Laplacian<a class="headerlink" href="#laplacian" title="Permalink to this headline">¶</a></h3>
<p>Fix an order on the vertices of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/>. The <em>Laplacian</em> of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is</p>
<div class="math">
<p><img src="_images/math/bd412bad7927d0b4482108e856dcd580b2fe27d1.png" alt="L := D-A" />
</div></p><p>where <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/> is the diagonal matrix of out-degrees of the vertices and <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is the
adjacency matrix whose <img class="math" src="_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)"/>-th entry is the weight of the edge from vertex
<img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> to vertex <img class="math" src="_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j"/>, which we take to be <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/> if there is no edge.  The <em>reduced
Laplacian</em>, <img class="math" src="_images/math/ab320834b985f08afd22278285379ecdad95e253.png" alt="\tilde{L}"/>, is the submatrix of the Laplacian formed by removing
the row and column corresponding to the sink vertex.  Firing a vertex of a
configuration is the same as subtracting the corresponding row of the reduced
Laplacian.</p>
<p><strong>Example.</strong> (Continued.)</p>
<div class="highlight-python"><pre>    sage: S.vertices()  # here is the ordering of the vertices
    [1, 2, 3, 'sink']
    sage: S.laplacian()
    [ 4 -1 -2 -1]
    [-1  2 -1  0]
    [-1 -1  2  0]
    [ 0  0  0  0]
    sage: S.reduced_laplacian()
    [ 4 -1 -2]
    [-1  2 -1]
    [-1 -1  2]

The configuration we considered previously:

    sage: c = Config(S, [5,0,1])
    sage: c
    {1: 5, 2: 0, 3: 1}

Firing vertex 1 is the same as subtracting the
corresponding row from the reduced Laplacian:

    sage: c.fire_vertex(1).values()
    [1, 1, 3]
    sage: S.reduced_laplacian()[0]
    (4, -1, -2)
    sage: vector([5,0,1]) - vector([4,-1,-2])
    (1, 1, 3)</pre>
</div>
</div>
<div class="section" id="recurrent-elements">
<h3>Recurrent elements<a class="headerlink" href="#recurrent-elements" title="Permalink to this headline">¶</a></h3>
<p>Imagine an experiment in which grains of sand are dropped one-at-a-time onto a
graph, pausing to allow the configuration to stabilize between drops.  Some
configurations will only be seen once in this process.  For example, for most
graphs, once sand is dropped on the graph, no addition of sand+stabilization
will result in a graph empty of sand.  Other configurations&#8212;the so-called
<em>recurrent configurations</em>&#8212;will be seen infinitely often as the process is
repeated indefinitely.</p>
<p>To be precise, a configuration <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is <em>recurrent</em> if (i) it is stable, and (ii)
given any configuration <img class="math" src="_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/>, there is a configuration <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> such that
<img class="math" src="_images/math/583a0b57c0b431ccdafc3864d8d42772e0345fdf.png" alt="c=\mbox{stab}(a+b)"/>, the stabilization of <img class="math" src="_images/math/add2609af1bb7632cc22b68fd49fdd94de06b327.png" alt="a+b"/>.</p>
<p>The <em>maximal-stable</em> configuration, denoted <img class="math" src="_images/math/a9e1c4d1dfaf0d83bc6e14c6fa846143bcaf4f29.png" alt="c_{\mathrm{max}}"/> is defined by
<img class="math" src="_images/math/c70c14eacc1201f20ac0810fdd89d49ba814e3d7.png" alt="c_{\mathrm{max}}(v)=\mbox{out-degree}(v)-1"/> for all nonsink vertices <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>.  It is clear that <img class="math" src="_images/math/a9e1c4d1dfaf0d83bc6e14c6fa846143bcaf4f29.png" alt="c_{\mathrm{max}}"/> is recurrent.  Further, it is not hard to see that a configuration is recurrent if and only if it has the form <img class="math" src="_images/math/fb1c4e7ab718de7c2bb321bc2d09a49ca9815a2f.png" alt="\mbox{stab}(a+c_{\mathrm{max}})"/> for some configuration <img class="math" src="_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/>.</p>
<p><strong>Example.</strong> (Continued.)</p>
<div class="highlight-python"><pre>    sage: S.recurrents(verbose=false)
    [[3, 1, 1], [2, 1, 1], [3, 1, 0]]
    sage: c = Config(S, [2,1,1])
    sage: c
    {1: 2, 2: 1, 3: 1}
    sage: S.is_recurrent(c)
    True
    sage: S.max_stable()
    {1: 3, 2: 1, 3: 1}

Adding any configuration to the max-stable configuration and stabilizing
yields a recurrent configuration.

    sage: x = Config(S, [1,0,0])
    sage: x + S.max_stable()
    {1: 4, 2: 1, 3: 1}

Use &amp; to add and stabilize:

    sage: c = x &amp; S.max_stable()
    sage: c
    {1: 3, 2: 1, 3: 0}
    sage: c.is_recurrent()
    True

Note the various ways of performing addition + stabilization:

    sage: (x + m).stabilize() == ~(x + m)
    True
    sage: (x + m).stabilize() == x &amp; m
    True</pre>
</div>
</div>
<div class="section" id="burning-configuration">
<h3>Burning Configuration<a class="headerlink" href="#burning-configuration" title="Permalink to this headline">¶</a></h3>
<p>A <em>burning configuration</em> is a nonnegative integer-linear combination of the
rows of the reduced Laplacian matrix having nonnegative entries and such that
every vertex has a path from some vertex in its support.  The corresponding
<em>burning script</em> gives the integer-linear combination needed to obtain the
burning configuration.  So if <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> is the burning configuration, <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> is its
script, and <img class="math" src="_images/math/ab320834b985f08afd22278285379ecdad95e253.png" alt="\tilde{L}"/> is the reduced Laplacian, then <img class="math" src="_images/math/302ecfae3ced08fa6e36604af01452ea89afcf54.png" alt="\sigma\,\tilde{L} = b"/>.
The <em>minimal burning configuration</em> is the one with the minimal script (its
components are no larger than the components of any other script for a burning
configuration).</p>
<p>The following are equivalent for a configuration <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> with burning
configuration <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> having script <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/>:</p>
<blockquote>
<ul class="simple">
<li><img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is recurrent;</li>
<li><img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> stabilizes to <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/>;</li>
<li>the firing vector for the stabilization of <img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> is <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/>.</li>
</ul>
</blockquote>
<p>The burning configuration and script are computed using a modified
version of Speer&#8217;s script algorithm.  This is a generalization to
directed multigraphs of Dhar&#8217;s burning algorithm.</p>
<p><strong>Example.</strong></p>
<div class="highlight-python"><pre>sage: g = {0:{},1:{0:1,3:1,4:1},2:{0:1,3:1,5:1},
           3:{2:1,5:1},4:{1:1,3:1},5:{2:1,3:1}}
sage: G = Sandpile(g,0)
sage: G.burning_config()
{1: 2, 2: 0, 3: 1, 4: 1, 5: 0}
sage: G.burning_config().values()
[2, 0, 1, 1, 0]
sage: G.burning_script()
{1: 1, 2: 3, 3: 5, 4: 1, 5: 4}
sage: G.burning_script().values()
[1, 3, 5, 1, 4]
sage: matrix(G.burning_script().values())*G.reduced_laplacian()
[2 0 1 1 0]</pre>
</div>
</div>
<div class="section" id="sandpile-group">
<h3>Sandpile group<a class="headerlink" href="#sandpile-group" title="Permalink to this headline">¶</a></h3>
<p>The collection of stable configurations forms a commutative monoid with
addition defined as ordinary addition followed by stabilization.  The identity
element is the all-zero configuration.  This monoid is a group
exactly when the underlying graph is a DAG (directed acyclic graph).</p>
<p>The recurrent elements form a submonoid which turns out to be a group.  This
group is called the <em>sandpile group</em> for <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/>, denoted
<img class="math" src="_images/math/8354fe6e8ac5f221618d9751e098c71c84cf6cb4.png" alt="\mathcal{S}(\Gamma)"/>.  Its identity element is usually not the all-zero
configuration (again, only in the case that <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is a DAG).  So finding the
identity element is an interesting problem.</p>
<p>Let <img class="math" src="_images/math/d465083b8dceb231fbf720f37260777d88dab1ba.png" alt="n=|V|-1"/> and fix an ordering of the nonsink vertices. Let
<img class="math" src="_images/math/00dc539ca54a7d3881a7b325363846cd221f8eea.png" alt="\mathcal{\tilde{L}}\subset\mathbb{Z}^n"/> denote the column-span of
<img class="math" src="_images/math/0e56a062e350b313084bf50579cd1b3ca11e3bf6.png" alt="\tilde{L}^t"/>, the transpose of the reduced Laplacian.  It is a theorem that</p>
<div class="math">
<p><img src="_images/math/5ec66952857f5ac6997fb15d8f659ecda9bf4565.png" alt="\mathcal{S}(\Gamma)\approx \mathbb{Z}^n/\mathcal{\tilde{L}}." />
</div></p><p>Thus, the number of elements of the sandpile group is <img class="math" src="_images/math/dd66a05f51a47bda0f748f1de2b9ddd4b3ce3863.png" alt="\det{\tilde{L}}"/>, which
by the matrix-tree theorem is the number of weighted trees directed into the
sink.</p>
<p><strong>Example.</strong> (Continued.)</p>
<div class="highlight-python"><pre>    sage: S.group_order()
    3
    sage: S.elementary_divisors()
    [1, 1, 3]
    sage: S.reduced_laplacian().dense_matrix().smith_form()

    ([1 0 0]
    [0 1 0]
    [0 0 3],
     [ 0  0  1]
    [ 1  0  0]
    [ 0  1 -1],
     [3 1 4]
    [4 1 6]
    [4 1 5])

Adding the identity to any recurrent configuration and stabilizing yields
the same recurrent configuration:

    sage: S.identity()
    {1: 3, 2: 1, 3: 0}
    sage: i = S.identity()
    sage: m = S.max_stable()
    sage: i &amp; m == m
    True</pre>
</div>
</div>
<div class="section" id="self-organized-criticality">
<h3>Self-organized criticality<a class="headerlink" href="#self-organized-criticality" title="Permalink to this headline">¶</a></h3>
<p>The sandpile model was introduced by Bak, Tang, and Wiesenfeld in the paper,
<em>Self-organized criticality: an explanation of 1/ƒ noise</em> <a class="reference internal" href="#btw">[BTW]</a>.  The term
<em>self-organized criticality</em> has no precise definition, but can be
loosely taken to describe a system that naturally evolves to a state that is
barely stable and such that the instabilities are described by a power law.
In practice, <em>self-organized criticality</em> is often taken to mean <em>like the
sandpile model on a grid-graph</em>.  The grid graph is just a grid with an extra
sink vertex.  The vertices on the interior of each side have one edge to the
sink, and the corner vertices have an edge of weight <img class="math" src="_images/math/41c544263a265ff15498ee45f7392c5f86c6d151.png" alt="2"/>.  Thus, every nonsink
vertex has out-degree <img class="math" src="_images/math/c7cab1a05e1e0c1d51a6a219d96577a16b7abf9d.png" alt="4"/>.</p>
<p>Imagine repeatedly dropping grains of sand on and empty grid graph, allowing
the sandpile to stabilize in between.  At first there is little activity, but
as time goes on, the size and extent of the avalanche caused by a single grain
of sand becomes hard to predict.  Computer experiments&#8212;I do not think there
is a proof, yet&#8212;indicate that the distribution of avalanche sizes obeys a
power law with exponent -1.  In the example below, the size of an avalanche is
taken to be the sum of the number of times each vertex fires.</p>
<p><strong>Example.</strong></p>
<div class="highlight-python"><pre>Distribution of avalanche sizes:

    sage: S = grid(10,10)
    sage: m = S.max_stable()
    sage: a = []
    sage: for i in range(10000):
    ...       m = m.add_random()
    ...       m, f = m.stabilize(true)
    ...       a.append(sum(f.values()))
    ...

    sage: p = list_plot([[log(i+1),log(a.count(i))] for i in [0..max(a)] if a.count(i)])
    sage: p.axes_labels(['log(N)','log(D(N))'])
    sage: p</pre>
</div>
<div align="center" class="figure">
<img alt="_images/btw.png" src="_images/btw.png" />
<p class="caption">Distribution of avalanche sizes</p>
</div>
<p>Note: In the above code, <tt class="docutils literal"><span class="pre">m.stabilize(true)</span></tt> returns a list consisting of the
stabilized configuration and the firing vector.  (Omitting <tt class="docutils literal"><span class="pre">true</span></tt> would give
just the stabilized configuration.)</p>
</div>
<div class="section" id="divisors-and-discrete-riemann-surfaces">
<span id="discrete-riemann-surfaces"></span><h3>Divisors and Discrete Riemann surfaces<a class="headerlink" href="#divisors-and-discrete-riemann-surfaces" title="Permalink to this headline">¶</a></h3>
<p>A reference for this section is <em>Riemann-Roch and Abel-Jacobi theory on a finite
graph</em> <a class="reference internal" href="#bn">[BN]</a>.</p>
<p>A <em>divisor</em> on <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is an element of the free abelian group on its
vertices, including the sink.  Suppose, as above, that the <img class="math" src="_images/math/0e3efd9b14723a92c2ae891fe27780d5f8e2b215.png" alt="n+1"/> vertices of
<img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> have been ordered, and that <img class="math" src="_images/math/f58392aca325862b9672f1ad5e9b2967461d6144.png" alt="\mathcal{L}"/> is the column span of the
transpose of the Laplacian.  A divisor is then identified with an element
<img class="math" src="_images/math/d6cbfa3576f6a4e70d91cff9d3b595f94e27a868.png" alt="D\in\mathbb{Z}^{n+1}"/> and two divisors are <em>linearly equivalent</em> if they
differ by an element of <img class="math" src="_images/math/f58392aca325862b9672f1ad5e9b2967461d6144.png" alt="\mathcal{L}"/>.  A divisor <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> is <em>effective</em>, written
<img class="math" src="_images/math/b944d22e3aa8ab1c68bcb515075b5a77cf1b41d2.png" alt="E\geq0"/>, if <img class="math" src="_images/math/d01a54fc0e4f6705ac94d669fe654a8700c7bd5a.png" alt="E(v)\geq0"/> for each <img class="math" src="_images/math/937313859c859123de0871aeadb9f67f5bf3911c.png" alt="v\in V"/>, i.e., if <img class="math" src="_images/math/f75fbc1c0c463d8a34d88c1520009a21ac846247.png" alt="E\in\mathbb{N}^{n+1}"/>.
The <em>degree</em> of a divisor, <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/>, is <img class="math" src="_images/math/cb69b4ecf2fdedccbb0bc7e318e8f915834536f3.png" alt="deg(D) := \sum_{v\in V}D(v)"/>.   The
divisors of degree zero modulo linear equivalence form the <em>Picard group</em>, or
<em>Jacobian</em> of the graph. For an undirected graph, the Picard group is
isomorphic to the sandpile group.</p>
<p>The <em>complete linear system</em> for a divisor <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/>, denoted <img class="math" src="_images/math/a012b9149bad1633c7aa2f027c5a4409c87dda78.png" alt="|D|"/>, is the
collection of effective divisors linearly equivalent to <img class="math" src="_images/math/c61f1e8be9d73f590167b39417e42bbaa1787fe0.png" alt="D."/></p>
<div class="section" id="riemann-roch">
<h4>Riemann-Roch<a class="headerlink" href="#riemann-roch" title="Permalink to this headline">¶</a></h4>
<p>To describe the Riemann-Roch theorem in this context, suppose that <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> is
an undirected, unweighted graph. The <em>dimension</em>, <img class="math" src="_images/math/baafb0ea48bd10f1845d9591f60e86a4d074680d.png" alt="r(D)"/> of the linear system
<img class="math" src="_images/math/a012b9149bad1633c7aa2f027c5a4409c87dda78.png" alt="|D|"/> is <img class="math" src="_images/math/bae5aba07d37ff6ff813107e76260fb31ad5794e.png" alt="-1"/> if <img class="math" src="_images/math/bdc399e7094d0a7bc886e709212316b1ae49d369.png" alt="|D|=\emptyset"/> and otherwise is the greatest integer <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> such
that <img class="math" src="_images/math/02b7bf0b0dea822c40a6fca9ce7b193c6cb4ac7d.png" alt="|D-E|\neq0"/> for all effective divisors <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> of degree <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/>.  Define the
<em>canonical divisor</em> by <img class="math" src="_images/math/c131338b0e2975ad68301a8b945be87250b16e0d.png" alt="K=\sum_{v\in V}(\deg(v)-2)v"/> and the <em>genus</em> by <img class="math" src="_images/math/8ae07586964d3c436536f191a445c79189339b62.png" alt="g =
\#(E) - \#(V) + 1"/>.  The Riemann-Roch theorem says that for any divisor <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/>,</p>
<div class="math">
<p><img src="_images/math/26fc1a9b10ff46a8542be8a259f8419349f00250.png" alt="r(D)-r(K-D)=\deg(D)+1-g." />
</div></p><p><strong>Example.</strong> (Some of the following calculations require the installation of <a class="reference internal" href="#installation"><em>4ti2</em></a>.)</p>
<div class="highlight-python"><pre>The sandpile on the complete graph on 5 vertices:

    sage: G = complete_sandpile(5)

The genus (num_edges method counts each undirected edge twice):

    sage: g = G.num_edges()/2 - G.num_verts() + 1

A divisor on the graph:

    sage: D = Divisor(G, [1,2,2,0,2])

Verify the Riemann-Roch theorem:

    sage: K = G.canonical_divisor()
    sage: D.r_of_D() - (K - D).r_of_D() == D.deg() + 1 - g
    True

The effective divisors linearly equivalent to D:

    sage: [E.values() for E in D.effective_div()]
    [[0, 1, 1, 4, 1], [4, 0, 0, 3, 0], [1, 2, 2, 0, 2]]

The nonspecial divisors up to linear equivalence (divisors of degree
g-1 with empty linear systems)

    sage: N = G.nonspecial_divisors()
    sage: [E.values() for E in N[:5]]   # the first few

    [[-1, 2, 1, 3, 0],
     [-1, 0, 3, 1, 2],
     [-1, 2, 0, 3, 1],
     [-1, 3, 1, 2, 0],
     [-1, 2, 0, 1, 3]]
    sage: len(N)
    24
    sage: len(N) == G.h_vector()[-1]
    True</pre>
</div>
</div>
<div class="section" id="picturing-linear-systems">
<h4>Picturing linear systems<a class="headerlink" href="#picturing-linear-systems" title="Permalink to this headline">¶</a></h4>
<p>Fix a divisor <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/>.  There are at least two natural graphs associated with
linear system associated with <img class="math" src="_images/math/9ffb448918db29f2a72f8f87f421b3b3cad18f95.png" alt="D"/>.  First, consider the directed graph with
vertex set <img class="math" src="_images/math/a012b9149bad1633c7aa2f027c5a4409c87dda78.png" alt="|D|"/> and with an edge from vertex <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> to vertex <img class="math" src="_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> if <img class="math" src="_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> is
attained from <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> by firing a single unstable vertex.</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(6),0)
sage: D = Divisor(S, [1,1,1,1,2,0])
sage: D.is_alive()
True
sage: eff = D.effective_div()
sage:
firing_graph(S,eff).show3d(edge_size=.005,vertex_size=0.01,iterations=500)</pre>
</div>
<div align="center" class="figure">
<img alt="_images/C_6.png" src="_images/C_6.png" />
<p class="caption">Complete linear system for (1,1,1,1,2,0) on <img class="math" src="_images/math/6d7224eb09d9655d0d96a43dcf188ea599482b4c.png" alt="C_6"/>: single firings</p>
</div>
<p>The second graph has the same set of vertices but with an edge from <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> to <img class="math" src="_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/>
if <img class="math" src="_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> is obtained from <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> by firing all unstable vertices of <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/>.</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(6),0)
sage: D = Divisor(S, [1,1,1,1,2,0])
sage: eff = D.effective_div()
sage: parallel_firing_graph(S,eff).show3d(edge_size=.005,vertex_size=0.01,iterations=500)</pre>
</div>
<div align="center" class="figure">
<img alt="_images/C_6-parallel.png" src="_images/C_6-parallel.png" />
<p class="caption">Complete linear system for (1,1,1,1,2,0) on <img class="math" src="_images/math/6d7224eb09d9655d0d96a43dcf188ea599482b4c.png" alt="C_6"/>: parallel firings</p>
</div>
<p>Note that in each of the examples, above, starting at any divisor in the linear
system and following edges, one is eventually led into a cycle of length 6
(cycling the divisor (1,1,1,1,2,0)).  Thus, <tt class="docutils literal"><span class="pre">D.alive()</span></tt> returns <tt class="xref docutils literal"><span class="pre">True</span></tt>.  In
Sage, one would be able to rotate the above figures to get a better idea of the
structure.</p>
</div>
</div>
<div class="section" id="algebraic-geometry-of-sandpiles">
<h3>Algebraic geometry of sandpiles<a class="headerlink" href="#algebraic-geometry-of-sandpiles" title="Permalink to this headline">¶</a></h3>
<p>A reference for the following material is in the works <a class="reference internal" href="#ppw">[PPW]</a>.</p>
<div class="section" id="affine">
<h4>Affine<a class="headerlink" href="#affine" title="Permalink to this headline">¶</a></h4>
<p>Let <img class="math" src="_images/math/d465083b8dceb231fbf720f37260777d88dab1ba.png" alt="n=|V|-1"/>, and fix an ordering on the nonsink vertices of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/>.  let
<img class="math" src="_images/math/a99d2c2b057cfa2a024b294dd6708819184f5306.png" alt="\tilde{\mathcal{L}}\subset\mathbb{Z}^n"/> denote the column-span of
<img class="math" src="_images/math/0e56a062e350b313084bf50579cd1b3ca11e3bf6.png" alt="\tilde{L}^t"/>, the transpose of the reduced Laplacian.  Label vertex <img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> with the
indeterminate <img class="math" src="_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i"/>, and let <img class="math" src="_images/math/e1ef1ba99ea450324dab0463f91ec0e0ad5e59cc.png" alt="\mathbb{C}[\Gamma_s] = \mathbb{C}[x_1,\dots,x_n]"/>.
(Here, <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> denotes the sink vertex of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/>.) The <em>sandpile ideal</em> or
<em>toppling ideal</em>, first studied by Cori, Rossin, and Salvy <a class="reference internal" href="#crs">[CRS]</a> for undirected graphs, is the lattice ideal for <img class="math" src="_images/math/259bb4a61367301d937a87dcaada85f408f35f7f.png" alt="\tilde{\mathcal{L}}"/>:</p>
<div class="math">
<p><img src="_images/math/fe585a5c73620931ddb2217cd4e222a78eaca500.png" alt="I = I(\Gamma_s) := \{x^u-x^v: u-v\in
\tilde{\mathcal{L}}\}\subset\mathbb{C}[\Gamma_s]," />
</div></p><p>where <img class="math" src="_images/math/e3afd3785fcc696f9b743ba8e25c11af4c1482ec.png" alt="x^u := \prod_{i=1}^nx^{u_i}"/> for <img class="math" src="_images/math/342104d6800c3039a1718021f5712a4ee473f756.png" alt="u\in\mathbb{Z}^n"/>.</p>
<p>For each <img class="math" src="_images/math/8e0a425961ada066277ed0003b49ac69336e4b86.png" alt="c\in\mathbb{Z}^n"/> define <img class="math" src="_images/math/8c630d31aad9dfdd864da183334afb4e97f21c8a.png" alt="t(c) = x^{c^+} - x^{c^-}"/> where
<img class="math" src="_images/math/d1e78864f08e492ae53bed25fb35d05fe62f4077.png" alt="c^+_i=\max\{c_i,0\}"/> and <img class="math" src="_images/math/e554ebb1e2e2a7b9326fd036fdabc006ee65df06.png" alt="c^-=\max\{-c_i,0\}"/> so that <img class="math" src="_images/math/409a5bdbd16b4cd6034efd914215dfe266790038.png" alt="c=c^+-c^-"/>.
Then, for each <img class="math" src="_images/math/df49974a8a1d56d3b460f29433255ddee017565d.png" alt="\sigma\in\mathbb{Z}^n"/>, define <img class="math" src="_images/math/d2a2a0783c0fbddab51965beb2969bb47cb9f5e5.png" alt="T(\sigma) =
t(\tilde{L}^t\sigma)"/>.  It then turns out that</p>
<div class="math">
<p><img src="_images/math/f07b1d3970155af1a776430e0cbaf318e3b4b7ed.png" alt="I = (T(e_1),\dots,T(e_n),x^b-1)" />
</div></p><p>where <img class="math" src="_images/math/26ae315076f64895667486f0c8faaa5ea17b5d59.png" alt="e_i"/> is the <img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/>-th standard basis vector and <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> is any burning
configuration.</p>
<p>The affine coordinate ring, <img class="math" src="_images/math/c86f192525ebd188ad7eba9f1677c8078a919e95.png" alt="\mathbb{C}[\Gamma_s]/I,"/> is isomorphic to the group
algebra of the sandpile group, <img class="math" src="_images/math/56f2228438171b93edb6630402ebc5382f18caf9.png" alt="\mathbb{C}[\mathcal{S}(\Gamma)]."/></p>
<p>The standard term-ordering on <img class="math" src="_images/math/3137ebe0914960c96f1bf4ced19fd81ae0d8b321.png" alt="\mathbb{C}[\Gamma_s]"/> is graded reverse
lexigraphical order with <img class="math" src="_images/math/3bcdfde50440cb0e02f2c140cbfe911e118f4782.png" alt="x_i&gt;x_j"/> if vertex <img class="math" src="_images/math/85ffd98b4eaea58a8db38fd0047e3a1d7c5661a0.png" alt="v_i"/> is further from the sink than
vertex <img class="math" src="_images/math/42628ab5952aa041b3649af187c7f256cfb4fe9d.png" alt="v_j"/>. (There are choices to be made for vertices equidistant from the
sink). If <img class="math" src="_images/math/ed8e6e2ce9e706282e19338acb915480ac2049f7.png" alt="\sigma_b"/> is the script for a burning configuration (not
necessarily minimal), then</p>
<div class="math">
<p><img src="_images/math/952f42c212d904ef0f795639468729ab5a40a483.png" alt="\{T(\sigma): \sigma\leq\sigma_b\}" />
</div></p><p>is a Groebner basis for <img class="math" src="_images/math/027f4a11d6090f9eac0ce2488df6384dad1263ea.png" alt="I"/>.</p>
</div>
<div class="section" id="projective">
<h4>Projective<a class="headerlink" href="#projective" title="Permalink to this headline">¶</a></h4>
<p>Now let <img class="math" src="_images/math/89b6b44feba8cbf1687365cfbcaff81331aff2f4.png" alt="\mathbb{C}[\Gamma]=\mathbb{C}[x_0,x_1,\dots,x_n]"/>, where <img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/>
corresponds to the sink vertex.  The <em>homogeneous sandpile ideal</em>, denoted
<img class="math" src="_images/math/badb14957a81e02c8715853351375efb2f66c8f2.png" alt="I^h"/>, is obtaining by homogenizing <img class="math" src="_images/math/027f4a11d6090f9eac0ce2488df6384dad1263ea.png" alt="I"/> with respect to <img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/>.  Let <img class="math" src="_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> be the
(full) Laplacian, and <img class="math" src="_images/math/3c0066fc5a8fcc98d41f4584503d6c97265fb895.png" alt="\mathcal{L}\subset\mathbb{Z}^{n+1}"/> be the column span of
its transpose, <img class="math" src="_images/math/ae66ff17ec76de85a9ab7dc4b556b02811310f20.png" alt="L^t."/>  Then <img class="math" src="_images/math/badb14957a81e02c8715853351375efb2f66c8f2.png" alt="I^h"/> is the lattice ideal for <img class="math" src="_images/math/f58392aca325862b9672f1ad5e9b2967461d6144.png" alt="\mathcal{L}"/>:</p>
<div class="math">
<p><img src="_images/math/efc956d162e507dd37203fc62f377ccd0e66e311.png" alt="I^h = I^h(\Gamma) := \{x^u-x^v: u-v \in\mathcal{L}\}\subset\mathbb{C}[\Gamma]." />
</div></p><p>This ideal can be calculated by saturating the ideal</p>
<div class="math">
<p><img src="_images/math/a15c535a3b1a74509b395d7dc89ed91cf1b45f1b.png" alt="(T(e_i): i=0,\dots n)" />
</div></p><p>with respect to the product of the indeterminates: <img class="math" src="_images/math/a73db17ea6204344ccc19685f885d170c99ea1cf.png" alt="\prod_{i=0}^nx_i"/> (extending
the <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> operator in the obvious way).  A Groebner basis with respect to the
degree lexicographic order describe above (with <img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/> the smallest vertex), is
obtained by homogenizing each element of the Groebner basis for the
non-homogeneous sandpile ideal with respect to <img class="math" src="_images/math/2a938a8fd06f751c6e286ee4980199090e9a0db7.png" alt="x_0."/></p>
<p><strong>Example.</strong></p>
<div class="highlight-python"><pre>    sage: g = {0:{},1:{0:1,3:1,4:1},2:{0:1,3:1,5:1},
               3:{2:1,5:1},4:{1:1,3:1},5:{2:1,3:1}}
    sage: S = Sandpile(g, 0)
    sage: S.ring()
    Multivariate Polynomial Ring in x5, x4, x3, x2, x1, x0 over Rational Field

The homogeneous sandpile ideal:

    sage: S.ideal()
    Ideal (x2 - x0, x3^2 - x5*x0, x5*x3 - x0^2, x4^2 - x3*x1, x5^2 - x3*x0, x1^3 - x4*x3*x0, x4*x1^2 - x5*x0^2)
    of Multivariate Polynomial Ring in x5, x4, x3, x2, x1, x0 over Rational Field

The generators of the ideal:

    sage: S.ideal(true)
    (x2 - x0,
     x3^2 - x5*x0,
     x5*x3 - x0^2,
     x4^2 - x3*x1,
     x5^2 - x3*x0,
     x1^3 - x4*x3*x0,
     x4*x1^2 - x5*x0^2)

Its resolution:

    sage: S.resolution()
    'R &lt;-- R^7 &lt;-- R^19 &lt;-- R^25 &lt;-- R^16 &lt;-- R^4'

and Betti table:

    sage: S.betti()
               0     1     2     3     4     5
    ------------------------------------------
        0:     1     1     -     -     -     -
        1:     -     4     6     2     -     -
        2:     -     2     7     7     2     -
        3:     -     -     6    16    14     4
    ------------------------------------------
    total:     1     7    19    25    16     4

The Hilbert function:

    sage: S.hilbert_function()
    [1, 5, 11, 15]

and its first differences (which counts the number of superstable
configurations in each degree):

    sage: S.h_vector()
    [1, 4, 6, 4]
    sage: x = [sum(i) for i in S.superstables(False)]
    sage: sorted(x)
    [0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

The degree in which the Hilbert function equals the Hilbert polynomial, the
latter always being a constant in the case of a sandpile ideal:

    sage: S.postulation()
    3</pre>
</div>
</div>
<div class="section" id="zeros">
<h4>Zeros<a class="headerlink" href="#zeros" title="Permalink to this headline">¶</a></h4>
<p>The <em>zero set</em> for the sandpile ideal <img class="math" src="_images/math/027f4a11d6090f9eac0ce2488df6384dad1263ea.png" alt="I"/> is</p>
<div class="math">
<p><img src="_images/math/3015fecd1dd6b009614265bc94daa7ef91aef6b1.png" alt="Z(I) = \{p\in\mathbb{C}^n: f(p)=0\mbox{ for all $f\in I$}\}," />
</div></p><p>the set of simultaneous zeros of the polynomials in <img class="math" src="_images/math/af494c05dedd30c53188b9b7a555309ec6163e78.png" alt="I."/>  Letting <img class="math" src="_images/math/0ee701409a18288d14acd5777a720835830b1e9e.png" alt="S^1"/> denote
the unit circle in the complex plane, <img class="math" src="_images/math/cc549e3abcc4737a625e9438b6a5aca82d408ce2.png" alt="Z(I)"/> is a finite
subgroup of <img class="math" src="_images/math/32ef4981dff9ed26af0463852bf0e2e1c87d66c9.png" alt="S^1\times\dots\times S^1\subset\mathbb{C}^n"/>, isomorphic to the
sandpile group.  The zero set is actually linearly isomorphic to a faithful representation of the sandpile group on <img class="math" src="_images/math/4ebaaa962a6ab782fc7248e0e3aeb9b458a9bdd7.png" alt="\mathbb{C}^n."/></p>
<p><strong>Example.</strong> (Continued.)</p>
<div class="highlight-python"><pre>     sage: S = Sandpile({0: {}, 1: {2: 2}, 2: {0: 4, 1: 1}}, 0)
     sage: S.ideal().gens()
     (x1^2 - x2^2, x1*x2^3 - x0^4, x2^5 - x1*x0^4)

Approximation to the zero set (setting ``x_0 = 1``):

     sage: S.solve()
     [[0.707107*I - 0.707107, 0.707107 - 0.707107*I],
      [-0.707107*I - 0.707107, 0.707107*I + 0.707107],
      [-1*I, -1*I],
      [I, I],
      [0.707107*I + 0.707107, -0.707107*I - 0.707107],
      [0.707107 - 0.707107*I, 0.707107*I - 0.707107],
      [1, 1],
      [-1, -1]]
     sage: len(_) == S.group_order()
     True

 The zeros are generated as a group by a single vector:

     sage: S.points()
     [[e^(1/4*I*pi), e^(-3/4*I*pi)]]</pre>
</div>
</div>
<div class="section" id="resolutions">
<h4>Resolutions<a class="headerlink" href="#resolutions" title="Permalink to this headline">¶</a></h4>
<p>The homogeneous sandpile ideal, <img class="math" src="_images/math/badb14957a81e02c8715853351375efb2f66c8f2.png" alt="I^h"/>, has a free resolution graded by the
divisors on <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> modulo linear equivalence.  (See the section on
<a class="reference internal" href="#discrete-riemann-surfaces"><em>Discrete Riemann Surfaces</em></a> for the language of
divisors and linear equivalence.)  Let
<img class="math" src="_images/math/2cb933567163075ccbd51b470c14654e26fc0b71.png" alt="S=\mathbb{C}[\Gamma]=\mathbb{C}[x_0,\dots,x_n]"/>, as above, and let
<img class="math" src="_images/math/41e3df2f23077d35947e0d5366a6d3589022eb48.png" alt="\mathfrak{S}"/> denote the group of divisors modulo rational equivalence.  Then
<img class="math" src="_images/math/ad28c83c99a8fd0dd2e2e594c9d02ee532765a0a.png" alt="S"/> is graded by <img class="math" src="_images/math/41e3df2f23077d35947e0d5366a6d3589022eb48.png" alt="\mathfrak{S}"/> by letting <img class="math" src="_images/math/9e44ae092c00f290eeb34a98cc86947240d40764.png" alt="\deg(x^c)= c\in\mathfrak{S}"/> for
each monomial <img class="math" src="_images/math/9d03b90f473a11ca34913d80bba00f60c16fda31.png" alt="x^c"/>.  The minimal free resolution of <img class="math" src="_images/math/badb14957a81e02c8715853351375efb2f66c8f2.png" alt="I^h"/> has the form</p>
<div class="math">
<p><img src="_images/math/a72c76ed95a3ae39870d6d3d18f9af42f71155c6.png" alt="0\leftarrow I^h
\leftarrow\oplus_{D\in\mathfrak{S}}S(-D)^{\beta_{0,D}}\leftarrow\oplus_{D\in\mathfrak{S}}S(-D)^{\beta_{1,D}}
\leftarrow\dots\leftarrow\oplus_{D\in\mathfrak{S}}S(-D)^{\beta_{r,D}}\leftarrow0." />
</div></p><p>where the <img class="math" src="_images/math/f7a2672c874ba8642dc1e2baf2630fae96936261.png" alt="\beta_{i,D}"/> are the <em>Betti numbers</em> for <img class="math" src="_images/math/badb14957a81e02c8715853351375efb2f66c8f2.png" alt="I^h"/>.</p>
<p>For each divisor class <img class="math" src="_images/math/0742f4889fe227d28293c7916da094ef3c8997aa.png" alt="D\in\mathfrak{S}"/>, define a simplicial complex,</p>
<div class="math">
<p><img src="_images/math/a9f3dbd3a87b6e2558ada1a4deeb04ab48d74116.png" alt="\Delta_D := \{I\subseteq\{0,\dots,n\}: I\subseteq\mbox{supp}(E)\mbox{ for some}\
E\in |D|\}." />
</div></p><p>The Betti number <img class="math" src="_images/math/f7a2672c874ba8642dc1e2baf2630fae96936261.png" alt="\beta_{i,D}"/> equals the dimension over <img class="math" src="_images/math/568df917149216103d9ba89ab22426e9449fb883.png" alt="\mathbb{C}"/> of the
<img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/>-th reduced homology group of <img class="math" src="_images/math/21811903b337db1ef0e0a982e822919b17ce3f18.png" alt="\Delta_D"/>:</p>
<div class="math">
<p><img src="_images/math/906d17d506887151c64a95912fbfcf7afd6ee76f.png" alt="\beta_{i,D} = \dim_{\mathbb{C}}\tilde{H}_i(\Delta_D;\mathbb{C})." />
</div></p><div class="highlight-python"><pre>        sage: S = Sandpile({0:{},1:{0: 1, 2: 1, 3: 4},2:{3: 5},3:{1: 1, 2: 1}},0)

Representatives of all divisor classes with nontrivial homology:

    sage: p = S.betti_complexes()
    sage: p[0]
    [{0: -8, 1: 5, 2: 4, 3: 1},
     Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2), (3,)}]

The homology associated with the first divisor in the list:

    sage: D = p[0][0]
    sage: S.effective_div(D)
    [{0: 0, 1: 1, 2: 1, 3: 0}, {0: 0, 1: 0, 2: 0, 3: 2}]
    sage: [S.support(E) for E in S.effective_div(D)]
    [[1, 2], [3]]
    sage: S.Dcomplex(D)
    Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2), (3,)}
    sage: S.Dcomplex(D).homology()
    {0: Z, 1: 0}


The minimal free resolution:

    sage: S.resolution()
    'R &lt;-- R^5 &lt;-- R^5 &lt;-- R^1'
    sage: S.betti()
               0     1     2     3
    ------------------------------
        0:     1     -     -     -
        1:     -     5     5     -
        2:     -     -     -     1
    ------------------------------
    total:     1     5     5     1
    sage: len(p)
    11

The degrees and ranks of the homology groups for each element of the list p
(compare with the Betti table, above):

    sage: [[sum(d[0].values()),d[1].betti()] for d in p]

    [[2, {0: 1, 1: 0}],
     [3, {0: 0, 1: 1, 2: 0}],
     [2, {0: 1, 1: 0}],
     [3, {0: 0, 1: 1, 2: 0}],
     [2, {0: 1, 1: 0}],
     [3, {0: 0, 1: 1, 2: 0}],
     [2, {0: 1, 1: 0}],
     [3, {0: 0, 1: 1}],
     [2, {0: 1, 1: 0}],
     [3, {0: 0, 1: 1, 2: 0}],
     [5, {0: 0, 1: 0, 2: 1}]]</pre>
</div>
</div>
<div class="section" id="complete-intersections-and-arithmetically-gorenstein-toppling-ideals">
<h4>Complete Intersections and Arithmetically Gorenstein toppling ideals<a class="headerlink" href="#complete-intersections-and-arithmetically-gorenstein-toppling-ideals" title="Permalink to this headline">¶</a></h4>
<p>NOTE: in the previous section note that the resolution always has length n since
the ideal is Cohen-Macaulay.</p>
<p>To do.</p>
</div>
<div class="section" id="betti-numbers-for-undirected-graphs">
<h4>Betti numbers for undirected graphs<a class="headerlink" href="#betti-numbers-for-undirected-graphs" title="Permalink to this headline">¶</a></h4>
<p>To do.</p>
</div>
</div>
</div>
<div class="section" id="installation">
<span id="id7"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>It is assumed that Sage is already installed.  If not, please see
the main <a class="reference external" href="http://www.sagemath.org">Sage homepage</a> for installation instructions.
To use <tt class="docutils literal"><span class="pre">sandpile.sage</span></tt>:</p>
<ul class="simple">
<li>download <a class="reference external" href="http://www.reed.edu/~davidp/sand">sandpile.sage</a></li>
<li>start Sage, and issue the command</li>
</ul>
<div class="highlight-python"><pre>sage: load sandpile.sage</pre>
</div>
<p>You may need to give the full path name to <tt class="docutils literal"><span class="pre">sandpile.sage</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The methods for computing linear systems of divisors and their corresponding
simplicial complexes require the installation of 4ti2.</p>
</div>
<p>To make 4ti2 usable from Sage Sandpiles there are two options:</p>
<ol class="arabic simple">
<li>Go to the <a class="reference external" href="http://sagemath.org/download-packages.html">Sage website</a> and
look for the precise names of the glpk and 4ti2 packages and install them
according to the instructions given there.  For instance, suppose the glpk
package is named glpk-4.9.spkg.  Install the package with the following
command from a UNIX shell prompt:</li>
</ol>
<div class="highlight-python"><pre>sage -i glpk-4.9</pre>
</div>
<ol class="arabic simple" start="2">
<li>Download the program from the <a class="reference external" href="http://www.4ti2.de/">4ti2 homepage</a>, and</li>
</ol>
<blockquote>
follow the installation instructions given there.</blockquote>
<ul class="simple">
<li>open <tt class="docutils literal"><span class="pre">sandpiles.sage</span></tt> in your favorite text editor and edit the following
line (near the beginning of the file, near the copyright statement and the
start of the definition of the Sandpile class), replacing the
<tt class="docutils literal"><span class="pre">path_to_zsolve</span></tt> string with the path to the executables in <em>your</em> 4ti2
directory:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="n">path_to_zsolve</span> <span class="o">=</span> <span class="s">&#39;/home/davidp/math/sandpile/4ti2/linux_x86/&#39;</span>
</pre></div>
</div>
<ul class="simple">
<li>start Sage and load <tt class="docutils literal"><span class="pre">sandpiles.sage</span></tt> as described above.</li>
</ul>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p>Most of <tt class="docutils literal"><span class="pre">sandpile.sage</span></tt> consists of the definition of the classes
<tt class="docutils literal"><span class="pre">Sandpile</span></tt>, <tt class="docutils literal"><span class="pre">Config</span></tt>, and <tt class="docutils literal"><span class="pre">Divisor</span></tt>.
Initialization for <tt class="docutils literal"><span class="pre">Sandpile</span></tt> has the form</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graph, sink)</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">graph</span></tt> represents a graph and <tt class="docutils literal"><span class="pre">sink</span></tt> is the key for the sink
vertex.  There are four possible forms for <tt class="docutils literal"><span class="pre">graph</span></tt>:</p>
<ol class="arabic simple">
<li>a Python dictionary of dictionaries:</li>
</ol>
<div class="highlight-python"><pre>sage: g = {0: {}, 1: {0: 1, 3: 1, 4: 1}, 2: {0: 1, 3: 1, 5: 1},
           3: {2: 1, 5: 1}, 4: {1: 1, 3: 1}, 5: {2: 1, 3: 1}}</pre>
</div>
<div align="center" class="figure">
<img alt="_images/initial.png" src="_images/initial.png" />
<p class="caption">Graph from dictionary of dictionaries.</p>
</div>
<p>Each key is the name of a vertex.  Next to each vertex name <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> is a dictionary
consisting of pairs: <tt class="docutils literal"><span class="pre">vertex:</span> <span class="pre">weight</span></tt>.  Each pair represents a directed edge
emanating from <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> and ending at <tt class="docutils literal"><span class="pre">vertex</span></tt> having (non-negative integer) weight
equal to <tt class="docutils literal"><span class="pre">weight</span></tt>.  Loops are allowed. In the example above, all of the weights are 1.</p>
<ol class="arabic simple" start="2">
<li>a Python dictionary of lists:</li>
</ol>
<div class="highlight-python"><pre>sage: g = {0: [], 1: [0, 3, 4], 2: [0, 3, 5],
           3: [2, 5], 4: [1, 3], 5: [2, 3]}</pre>
</div>
<p>This is a short-hand when all of the edge-weights are equal to 1.  The above
example is for the same displayed graph.</p>
<ol class="arabic simple" start="3">
<li>a Sage graph (of type <tt class="docutils literal"><span class="pre">sage.graphs.graph.Graph</span></tt>):</li>
</ol>
<div class="highlight-python"><pre>sage: g = graphs.CycleGraph(5)
sage: S = Sandpile(g, 0)
sage: type(g)
&lt;class 'sage.graphs.graph.Graph'&gt;</pre>
</div>
<p>To see the types of built-in graphs, type <tt class="docutils literal"><span class="pre">graphs.</span></tt>, including the period,
and hit TAB.</p>
<ol class="arabic simple" start="4">
<li>a Sage digraph:</li>
</ol>
<div class="highlight-python"><pre>sage: S = Sandpile(digraphs.RandomDirectedGNC(6), 0)
sage: S.show()</pre>
</div>
<div align="center" class="figure">
<img alt="_images/random.png" src="_images/random.png" />
<p class="caption">A random graph.</p>
</div>
<p>See <a class="reference external" href="http://sagemath.org/doc/reference/sage/graphs/graph_generators.html">http://sagemath.org/doc/reference/sage/graphs/graph_generators.html</a> for
more information on the Sage graph library and graph constructors.</p>
<p>Each of these four formats is preprocessed by the Sandpile class so that,
internally, the graph is represented by the dictionary of dictionaries format
first presented.  This internal format is returned by  <tt class="docutils literal"><span class="pre">dict()</span></tt>:</p>
<div class="highlight-python"><pre>sage: S  = Sandpile({0:[], 1:[0, 3, 4], 2:[0, 3, 5],
                     3: [2, 5], 4: [1, 3], 5: [2, 3]},0)
sage: S.dict()

{0: {},
 1: {0: 1, 3: 1, 4: 1},
 2: {0: 1, 3: 1, 5: 1},
 3: {2: 1, 5: 1},
 4: {1: 1, 3: 1},
 5: {2: 1, 3: 1}}</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The user is responsible for assuring that each vertex has a directed path
into the designated sink.  If the sink has out-edges, these will be ignored
for the purposes of sandpile calculations (but not calculations on divisors).</p>
</div>
<p><strong>Code for checking whether a given vertex is a sink:</strong></p>
<div class="highlight-python"><pre>sage:  S  = Sandpile({0:[], 1:[0, 3, 4], 2:[0, 3, 5],
                         3: [2, 5], 4: [1, 3], 5: [2, 3]},0)
sage: [S.distance(v,0) for v in S.vertices()] # 0 is a sink
[0, 1, 1, 2, 2, 2]
sage: [S.distance(v,1) for v in S.vertices()] # 1 is not a sink
[+Infinity, 0, +Infinity, +Infinity, 1, +Infinity]</pre>
</div>
</div>
<div class="section" id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h3>
<p>Here are summaries of <tt class="docutils literal"><span class="pre">Sandpile</span></tt>, <tt class="docutils literal"><span class="pre">Config</span></tt>, and <tt class="docutils literal"><span class="pre">Divisor</span></tt> methods
(functions).  Each summary is followed by a list of complete descriptions of
the methods.  There are many more methods available for a Sandpile, e.g.,
those inherited from the class DiGraph.  To see them all, enter</p>
<div class="highlight-python"><pre>sage: dir(Sandpile)</pre>
</div>
<p>or type <tt class="docutils literal"><span class="pre">Sandpile.</span></tt>, including the period, and hit TAB.</p>
<div class="section" id="sandpile">
<h4>Sandpile<a class="headerlink" href="#sandpile" title="Permalink to this headline">¶</a></h4>
<p><strong>Summary of methods.</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#all-k-config-k"><em>all_k_config(k)</em></a> &#8212; The configuration with all values set to k.</li>
<li><a class="reference internal" href="#all-k-div-k"><em>all_k_div(k)</em></a> &#8212; The divisor with all values set to k.</li>
<li><a class="reference internal" href="#betti-verbose"><em>betti(verbose)</em></a> &#8212; The Betti table for the
homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#betti-complexes"><em>betti_complexes()</em></a> &#8212; The divisors with
nonempty linear systems along with their with their simplicial complexes.</li>
<li><a class="reference internal" href="#burning-config"><em>burning_config()</em></a> &#8212; A minimal burning configuration.</li>
<li><a class="reference internal" href="#burning-script"><em>burning_script()</em></a> &#8212; A script for the minimal burning configuration.</li>
<li><a class="reference internal" href="#canonical-divisor"><em>canonical_divisor()</em></a> &#8212; The canonical divisor (for undirected graphs).</li>
<li><a class="reference internal" href="#dict"><em>dict()</em></a> &#8212; A dictionary of dictionaries representing a directed graph.</li>
<li><a class="reference internal" href="#elementary-divisors"><em>elementary_divisors()</em></a> &#8212; The elementary
divisors of the sandpile group (a finite abelian group).</li>
<li><a class="reference internal" href="#groebner"><em>groebner()</em></a> &#8212; Groebner basis for the homogeneous
sandpile ideal with respect to the standard sandpile ordering.</li>
<li><a class="reference internal" href="#group-order"><em>group_order()</em></a> &#8212; The size of the sandpile group.</li>
<li><a class="reference internal" href="#h-vector"><em>h_vector()</em></a> &#8212; The first differences of the
Hilbert function of the homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#hilbert-function"><em>hilbert_function()</em></a> &#8212; The Hilbert function of the homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#ideal"><em>ideal()</em></a> &#8212; The saturated, homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#identity"><em>identity()</em></a> &#8212; The identity configuration.</li>
<li><a class="reference internal" href="#in-degree-v"><em>in_degree(v)</em></a> &#8212; The in-degree of a vertex or a list of all in-degrees.</li>
<li><a class="reference internal" href="#is-undirected"><em>is_undirected()</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">(u,v)</span></tt> is and edge if and only if <tt class="docutils literal"><span class="pre">(v,u)</span></tt> is an edges, each edge with the same weight.</li>
<li><a class="reference internal" href="#id8"><em>laplacian()</em></a> &#8212; The Laplacian matrix of the graph.</li>
<li><a class="reference internal" href="#max-stable"><em>max_stable()</em></a> &#8212; The maximal stable configuration.</li>
<li><a class="reference internal" href="#max-stable-div"><em>max_stable_div()</em></a> &#8212; The maximal stable divisor.</li>
<li><a class="reference internal" href="#max-superstables"><em>max_superstables()</em></a> &#8212; The maximal superstable
configurations.</li>
<li><a class="reference internal" href="#min-recurrents"><em>min_recurrents()</em></a> &#8212; The minimal recurrent
elements.</li>
<li><a class="reference internal" href="#nonsink-vertices"><em>nonsink_vertices()</em></a> &#8212; The names of the nonsink vertices.</li>
<li><a class="reference internal" href="#nonspecial-divisors"><em>nonspecial_divisors()</em></a> &#8212; The nonspecial
divisors (only for undirected graphs).</li>
<li><a class="reference internal" href="#num-edges"><em>num_edges()</em></a> &#8212; The number of edges.</li>
<li><a class="reference internal" href="#out-degree-v"><em>out_degree(v)</em></a> &#8212; The out-degree of a vertex or a list of all out-degrees.</li>
<li><a class="reference internal" href="#points"><em>points()</em></a> &#8212; Generators for the multiplicative group of
zeros of the sandpile ideal.</li>
<li><a class="reference internal" href="#postulation"><em>postulation()</em></a> &#8212; The postulation number of the sandpile ideal.</li>
<li><a class="reference internal" href="#recurrents-verbose"><em>recurrents(verbose)</em></a> &#8212; The list of recurrent
configurations.</li>
<li><a class="reference internal" href="#reduced-laplacian"><em>reduced_laplacian()</em></a> &#8212; The reduced Laplacian matrix of the graph.</li>
<li><a class="reference internal" href="#reorder-vertices"><em>reorder_vertices()</em></a> &#8212; Create a copy of the
sandpile but with the vertices reordered</li>
<li><a class="reference internal" href="#resolution-verbose"><em>resolution(verbose)</em></a> &#8212; The
minimal free resolution of the homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#ring"><em>ring()</em></a> &#8212; The ring containing the homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#sink"><em>sink()</em></a> &#8212; The identifier for the sink vertex.</li>
<li><a class="reference internal" href="#solve"><em>solve()</em></a> &#8212; Approximations of the complex affine zeros of the sandpile ideal.</li>
<li><a class="reference internal" href="#superstables-verbose"><em>superstables(verbose)</em></a> &#8212; The list of
superstable configurations.</li>
<li><a class="reference internal" href="#symmetric-recurrents-orbits"><em>symmetric_recurrents(orbits)</em></a> &#8212; The list of symmetric recurrent configurations.</li>
<li><a class="reference internal" href="#unsaturated-ideal"><em>unsaturated_ideal()</em></a> &#8212; The unsaturated, homogeneous sandpile ideal.</li>
<li><a class="reference internal" href="#version"><em>version()</em></a> &#8212; The version number of Sage Sandpiles.</li>
<li><a class="reference internal" href="#vertices-boundary-first"><em>vertices(boundary_first)</em></a> &#8212; The list</li>
<li><a class="reference internal" href="#zero-config"><em>zero_config()</em></a> &#8212; The all-zero configuration.</li>
<li><a class="reference internal" href="#zero-div"><em>zero_div()</em></a> &#8212; The all-zero divisor.</li>
</ul>
<hr class="docutils" />
<p><strong>Complete descriptions of Sandpile methods.</strong></p>
<p>&#8212;</p>
<p id="all-k-config-k"><strong>all_k_config(k)</strong></p>
<blockquote>
<p>The configuration with all values set to k.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">k</span></tt> - integer</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.all_k_config(7)
{1: 7, 2: 7, 3: 7, 4: 7, 5: 7}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="all-k-div-k"><strong>all_k_div(k)</strong></p>
<blockquote>
<p>The divisor with all values set to k.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">k</span></tt> - integer</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.all_k_div(7)
{0: 7, 1: 7, 2: 7, 3: 7, 4: 7, 5: 7}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="betti-verbose"><strong>betti(verbose)</strong></p>
<blockquote>
<p>Computes the Betti table for the homogeneous sandpile ideal.  If
<tt class="docutils literal"><span class="pre">verbose</span></tt> is <tt class="xref docutils literal"><span class="pre">True</span></tt>, it prints the standard Betti table, otherwise,
it returns a less formated table.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">verbose</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>Betti numbers for the sandpile</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.betti()
           0     1     2     3     4     5
------------------------------------------
    0:     1     1     -     -     -     -
    1:     -     4     6     2     -     -
    2:     -     2     7     7     2     -
    3:     -     -     6    16    14     4
------------------------------------------
total:     1     7    19    25    16     4
sage: S.betti(false)
[1, 7, 19, 25, 16, 4]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="betti-complexes"><strong>betti_complexes()</strong></p>
<blockquote>
<p>Returns a list of all the divisors with nonempty linear systems whose
corresponding simplicial complexes have nonzero homology in some
dimension. Each such divisors is returned with its corresponding
simplicial complex.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list (of pairs [divisors, corresponding simplicial complex])</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile({0:{},1:{0: 1, 2: 1, 3: 4},2:{3: 5},3:{1: 1, 2: 1}},0)
sage: p = S.betti_complexes()
sage: p[0]
[{0: -8, 1: 5, 2: 4, 3: 1},
 Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2), (3,)}]
sage: S.resolution()
'R &lt;-- R^5 &lt;-- R^5 &lt;-- R^1'
sage: S.betti()
           0     1     2     3
------------------------------
    0:     1     -     -     -
    1:     -     5     5     -
    2:     -     -     -     1
------------------------------
total:     1     5     5     1
sage: len(p)
11
sage: p[0][1].homology()
{0: Z, 1: 0}
sage: p[-1][1].homology()
{0: 0, 1: 0, 2: Z}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="burning-config"><strong>burning_config()</strong></p>
<blockquote>
<p>A minimal burning configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>dict (configuration)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: g = {0:{},1:{0:1,3:1,4:1},2:{0:1,3:1,5:1},
           3:{2:1,5:1},4:{1:1,3:1},5:{2:1,3:1}}
sage: S = Sandpile(g,0)
sage: S.burning_config()
{1: 2, 2: 0, 3: 1, 4: 1, 5: 0}
sage: S.burning_config().values()
[2, 0, 1, 1, 0]
sage: S.burning_script()
{1: 1, 2: 3, 3: 5, 4: 1, 5: 4}
sage: script = S.burning_script().values()
sage: script
[1, 3, 5, 1, 4]
sage: matrix(script)*S.reduced_laplacian()
[2 0 1 1 0]</pre>
</div>
<p>NOTES:</p>
<p>The burning configuration and script are computed using a modified
version of Speer&#8217;s script algorithm.  This is a generalization to
directed multigraphs of Dhar&#8217;s burning algorithm.</p>
<p>A <em>burning configuration</em> is a nonnegative integer-linear
combination of the rows of the reduced Laplacian matrix having
nonnegative entries and such that every vertex has a path from some
vertex in its support.  The corresponding <em>burning script</em> gives
the integer-linear combination needed to obtain the burning
configuration.  So if <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> is the burning configuration, <img class="math" src="_images/math/215a58fb239bfb2341ff00f4658a982cce285ac1.png" alt="sigma"/> is its
script, and <img class="math" src="_images/math/a00cf639a61daf26e0811c0c032de30a91d30871.png" alt="tilde{L}"/> is the reduced Laplacian, then <img class="math" src="_images/math/172e21425bc2303902c05c9d89f0cb40fc68fd20.png" alt="sigma *
tilde{L} = b"/>.  The <em>minimal burning configuration</em> is the one
with the minimal script (its components are no larger than the
components of any other script
for a burning configuration).</p>
<p>The following are equivalent for a configuration <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> with burning
configuration <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> having script <img class="math" src="_images/math/215a58fb239bfb2341ff00f4658a982cce285ac1.png" alt="sigma"/>:</p>
<blockquote>
<ul class="simple">
<li><img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is recurrent;</li>
<li><img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> stabilizes to <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/>;</li>
<li>the firing vector for the stabilization of <img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> is <img class="math" src="_images/math/215a58fb239bfb2341ff00f4658a982cce285ac1.png" alt="sigma"/>.</li>
</ul>
</blockquote>
</blockquote>
<p>&#8212;</p>
<p id="burning-script"><strong>burning_script()</strong></p>
<blockquote>
<p>A script for the minimal burning configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>dict</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: g = {0:{},1:{0:1,3:1,4:1},2:{0:1,3:1,5:1},
           3:{2:1,5:1},4:{1:1,3:1},5:{2:1,3:1}}
sage: S = Sandpile(g,0)
sage: S.burning_config()
{1: 2, 2: 0, 3: 1, 4: 1, 5: 0}
sage: S.burning_config().values()
[2, 0, 1, 1, 0]
sage: S.burning_script()
{1: 1, 2: 3, 3: 5, 4: 1, 5: 4}
sage: script = S.burning_script().values()
sage: script
[1, 3, 5, 1, 4]
sage: matrix(script)*S.reduced_laplacian()
[2 0 1 1 0]</pre>
</div>
<p>NOTES:</p>
<p>The burning configuration and script are computed using a modified
version of Speer&#8217;s script algorithm.  This is a generalization to
directed multigraphs of Dhar&#8217;s burning algorithm.</p>
<p>A <em>burning configuration</em> is a nonnegative integer-linear
combination of the rows of the reduced Laplacian matrix having
nonnegative entries and such that every vertex has a path from some
vertex in its support.  The corresponding <em>burning script</em> gives the
integer-linear combination needed to obtain the burning configuration.
So if <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> is the burning configuration, <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> is its script, and
<img class="math" src="_images/math/0666c126c5e354b23b226dc1fd114109cdd2714d.png" alt="L_{mathrm{red}}"/> is the reduced Laplacian, then <img class="math" src="_images/math/6bb3ca9b7ad1315c89d9b0b2fd313691ffac10ea.png" alt="s *
L_{mathrm{red}}= b"/>.  The <em>minimal burning configuration</em> is the one
with the minimal script (its components are no larger than the
components of any other script
for a burning configuration).</p>
<p>The following are equivalent for a configuration <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> with burning
configuration <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> having script <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/>:</p>
<blockquote>
<ul class="simple">
<li><img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is recurrent;</li>
<li><img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> stabilizes to <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/>;</li>
<li>the firing vector for the stabilization of <img class="math" src="_images/math/560e9cf4659c7670b427fffa46be9c37b3c2fe2c.png" alt="c+b"/> is <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/>.</li>
</ul>
</blockquote>
</blockquote>
<p>&#8212;</p>
<p id="canonical-divisor"><strong>canonical_divisor()</strong></p>
<blockquote>
<p>Returns the canonical divisor: the divisor <tt class="docutils literal"><span class="pre">deg(v)-2</span></tt> grains of sand
on each vertex.  Only for undirected graphs.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = complete_sandpile(4)
sage: S.canonical_divisor()
{0: 1, 1: 1, 2: 1, 3: 1}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="dict"><strong>dict()</strong></p>
<blockquote>
<p>Returns a dictionary of dictionaries representing a directed graph.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>dict</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: G = sandlib('generic')
sage: G.dict()
{0: {},
 1: {0: 1, 3: 1, 4: 1},
 2: {0: 1, 3: 1, 5: 1},
 3: {2: 1, 5: 1},
 4: {1: 1, 3: 1},
 5: {2: 1, 3: 1}}
sage: G.sink()
0</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="elementary-divisors"><strong>elementary_divisors()</strong></p>
<blockquote>
<p>The elementary divisors of the sandpile group (a finite
abelian group).</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of integers</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.elementary_divisors()
[1, 1, 1, 1, 15]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="groebner"><strong>groebner()</strong></p>
<blockquote>
<p>Returns a Groebner basis for the homogeneous sandpile ideal with
respect to the standard sandpile ordering (see <tt class="docutils literal"><span class="pre">ring</span></tt>).</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Groebner basis</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.groebner()
[x4*x1^2 - x5*x0^2, x1^3 - x4*x3*x0, x5^2 - x3*x0, x4^2 - x3*x1, x5*x3 - x0^2, x3^2 - x5*x0, x2 - x0]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="group-order"><strong>group_order()</strong></p>
<blockquote>
<p>Returns the size of the sandpile group.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>int</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.group_order()
15</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="h-vector"><strong>h_vector()</strong></p>
<blockquote>
<p>Returns the first differences of the Hilbert function of the homogeneous
sandpile ideal.  It lists the number of superstable configurations in
each degree.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of nonnegative integers</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.hilbert_function()
[1, 5, 11, 15]
sage: S.h_vector()
[1, 4, 6, 4]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="hilbert-function"><strong>hilbert_function()</strong></p>
<blockquote>
<p>Returns the Hilbert function of the homogeneous sandpile ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of nonnegative integers</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.hilbert_function()
[1, 5, 11, 15]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="ideal"><strong>ideal()</strong></p>
<blockquote>
<p>The saturated, homogeneous sandpile ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>ideal</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.ideal()
Ideal (x2 - x0, x3^2 - x5*x0, x5*x3 - x0^2, x4^2 - x3*x1, x5^2 - x3*x0, x1^3 - x4*x3*x0, x4*x1^2 - x5*x0^2)
of Multivariate Polynomial Ring in x5, x4, x3, x2, x1, x0 over Rational Field
sage: S.ideal(true)
(x2 - x0,
 x3^2 - x5*x0,
 x5*x3 - x0^2,
 x4^2 - x3*x1,
 x5^2 - x3*x0,
 x1^3 - x4*x3*x0,
 x4*x1^2 - x5*x0^2)
 sage: S.ideal().gens()  # another way to get the generators
(x2 - x0,
 x3^2 - x5*x0,
 x5*x3 - x0^2,
 x4^2 - x3*x1,
 x5^2 - x3*x0,
 x1^3 - x4*x3*x0,
 x4*x1^2 - x5*x0^2)</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="identity"><strong>identity()</strong></p>
<blockquote>
<p>Returns the identity configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>dict (the identity configuration)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: e = S.identity()
sage: x = e &amp; S.max_stable()  # stable addition
sage: x
{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}
sage: x == S.max_stable()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="in-degree-v"><strong>in_degree(v)</strong></p>
<blockquote>
<p>Return the in-degree of a vertex or a list of all in-degrees.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">v</span></tt> - vertex name or None</p>
<p>OUTPUT:</p>
<p>integer or dict</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.in_degree(2)
2
sage: S.in_degree()
{0: 2, 1: 1, 2: 2, 3: 4, 4: 1, 5: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-undirected"><strong>is_undirected()</strong></p>
<blockquote>
<p>Returns <tt class="xref docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">(u,v)</span></tt> is and edge if and only if <tt class="docutils literal"><span class="pre">(v,u)</span></tt> is an
edges, each edge with the same weight.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: complete_sandpile(4).is_undirected()
True
sage: sandlib('gor').is_undirected()
False</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="id8"><strong>laplacian()</strong></p>
<blockquote>
<p>Returns the Laplacian matrix of the graph.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>matrix</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: G = sandlib('generic')
sage: G.laplacian()
[ 0  0  0  0  0  0]
[-1  3  0 -1 -1  0]
[-1  0  3 -1  0 -1]
[ 0  0 -1  2  0 -1]
[ 0 -1  0 -1  2  0]
[ 0  0 -1 -1  0  2]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="max-stable"><strong>max_stable()</strong></p>
<blockquote>
<p>Returns the maximal stable configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config (the maximal stable configuration)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.max_stable()
{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="max-stable-div"><strong>max_stable_div()</strong></p>
<blockquote>
<p>Returns the maximal stable divisor.</p>
<p>INPUT:</p>
<p>Divisor</p>
<p>OUTPUT:</p>
<p>Divisor (the maximal stable divisor)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.max_stable_div()
{0: -1, 1: 2, 2: 2, 3: 1, 4: 1, 5: 1}
sage: S.out_degree()
{0: 0, 1: 3, 2: 3, 3: 2, 4: 2, 5: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="max-superstables"><strong>max_superstables()</strong></p>
<blockquote>
<p>EXAMPLES:</p>
<blockquote>
<p>sage: S=sandlib(&#8216;riemann-roch2&#8217;)
sage: S.max_superstables()
[{1: 1, 2: 1, 3: 1}, {1: 0, 2: 0, 3: 2}]
sage: [i.values() for i in S.superstables()]
[[0, 0, 0],</p>
<blockquote>
[1, 0, 1],
[1, 0, 0],
[0, 1, 1],
[0, 1, 0],
[1, 1, 0],
[0, 0, 1],
[1, 1, 1],
[0, 0, 2]]</blockquote>
<p>sage: S.h_vector()
[1, 3, 4, 1]</p>
</blockquote>
</blockquote>
<p>&#8212;</p>
<p id="min-recurrents"><strong>min_recurrents()</strong></p>
<blockquote>
<p>Returns the minimal recurrent elements.  If the underlying graph is
undirected, these are the recurrent elements of least degree.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S=sandlib('riemann-roch2')
sage: S.min_recurrents()
[{1: 0, 2: 0, 3: 1}, {1: 1, 2: 1, 3: 0}]
sage: [i.values() for i in S.recurrents()]
[[1, 1, 2],
 [0, 1, 1],
 [0, 1, 2],
 [1, 0, 1],
 [1, 0, 2],
 [0, 0, 2],
 [1, 1, 1],
 [0, 0, 1],
 [1, 1, 0]]
sage: [i.deg() for i in S.recurrents()]
[4, 2, 3, 2, 3, 2, 3, 1, 2]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="nonsink-vertices"><strong>nonsink_vertices()</strong></p>
<blockquote>
<p>The names of the nonsink vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>None</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.nonsink_vertices()
[1, 2, 3, 4, 5]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="nonspecial-divisors"><strong>nonspecial_divisors()</strong></p>
<blockquote>
<p>Returns the nonspecial divisors: those divisors of degree <tt class="docutils literal"><span class="pre">g-1</span></tt> with
empty linear system.  The term is only defined for undirected graphs.
Here, <tt class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">|E|</span> <span class="pre">-</span> <span class="pre">|V|</span> <span class="pre">+</span> <span class="pre">1</span></tt> is the genus of the graph.</p>
<p>INPUT:</p>
<p>OUTPUT:</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = complete_sandpile(4)
sage: ns = S.nonspecial_divisors()
sage: D = ns[0]
sage: D.values()
[-1, 1, 0, 2]
sage: D.deg()
2
sage: [i.effective_div() for i in ns]
[[], [], [], [], [], []]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="num-edges"><strong>num_edges()</strong></p>
<blockquote>
<p>Returns the number of edges.</p>
<dl class="docutils">
<dt>EXAMPLES::</dt>
<dd>sage: G = graphs.PetersenGraph()
sage: G.size()
15</dd>
</dl>
</blockquote>
<p>&#8212;</p>
<p id="out-degree-v"><strong>out_degree(v)</strong></p>
<blockquote>
<p>Return the out-degree of a vertex or a list of all out-degrees.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">v</span></tt> (optional) - vertex name</p>
<p>OUTPUT:</p>
<p>integer or dict</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.out_degree(2)
3
sage: S.out_degree()
{0: 0, 1: 3, 2: 3, 3: 2, 4: 2, 5: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="points"><strong>points()</strong></p>
<blockquote>
<p>Returns generators for the multiplicative group of zeros of the sandpile
ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of complex numbers</p>
<p>EXAMPLES:</p>
<p>The sandpile group in this example is cyclic, and hence there is a
single generator for the group of solutions.</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.points()
[[e^(4/5*I*pi), 1, e^(2/3*I*pi), e^(-34/15*I*pi), e^(-2/3*I*pi)]]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="postulation"><strong>postulation()</strong></p>
<blockquote>
<p>Returns the postulation number of the sandpile ideal.  This is the
largest weight of a superstable configuration of the graph.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>nonnegative integer</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.postulation()
3</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="recurrents-verbose"><strong>recurrents(verbose)</strong></p>
<blockquote>
<p>Returns the list of recurrent configurations. If <tt class="docutils literal"><span class="pre">verbose</span></tt>
is <tt class="xref docutils literal"><span class="pre">False</span></tt>, the configurations are converted to lists of
integers.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">verbose</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>list (of recurrent configurations)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.recurrents()
[{1: 2, 2: 2, 4: 1, 4: 1, 5: 1},
 {1: 2, 2: 2, 3: 0, 4: 1, 5: 1},
 {1: 0, 2: 2, 3: 1, 4: 1, 5: 0},
 {1: 0, 2: 2, 3: 1, 4: 1, 5: 1},
 {1: 1, 2: 2, 3: 1, 4: 1, 5: 1},
 {1: 1, 2: 2, 3: 0, 4: 1, 5: 1},
 {1: 2, 2: 2, 3: 1, 4: 0, 5: 1},
 {1: 2, 2: 2, 3: 0, 4: 0, 5: 1},
 {1: 2, 2: 2, 3: 1, 4: 0, 5: 0},
 {1: 1, 2: 2, 3: 1, 4: 1, 5: 0},
 {1: 1, 2: 2, 3: 1, 4: 0, 5: 0},
 {1: 1, 2: 2, 3: 1, 4: 0, 5: 1},
 {1: 0, 2: 2, 3: 0, 4: 1, 5: 1},
 {1: 2, 2: 2, 3: 1, 4: 1, 5: 0},
 {1: 1, 2: 2, 3: 0, 4: 0, 5: 1}]
sage: S.recurrents(false)
[[2, 2, 1, 1, 1],
 [2, 2, 0, 1, 1],
 [0, 2, 1, 1, 0],
 [0, 2, 1, 1, 1],
 [1, 2, 1, 1, 1],
 [1, 2, 0, 1, 1],
 [2, 2, 1, 0, 1],
 [2, 2, 0, 0, 1],
 [2, 2, 1, 0, 0],
 [1, 2, 1, 1, 0],
 [1, 2, 1, 0, 0],
 [1, 2, 1, 0, 1],
 [0, 2, 0, 1, 1],
 [2, 2, 1, 1, 0],
 [1, 2, 0, 0, 1]]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="reduced-laplacian"><strong>reduced_laplacian()</strong></p>
<blockquote>
<p>Returns the reduced Laplacian matrix of the graph.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>matrix</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: G = sandlib('generic')
sage: G.laplacian()
[ 0  0  0  0  0  0]
[-1  3  0 -1 -1  0]
[-1  0  3 -1  0 -1]
[ 0  0 -1  2  0 -1]
[ 0 -1  0 -1  2  0]
[ 0  0 -1 -1  0  2]
sage: G.reduced_laplacian()
[ 3  0 -1 -1  0]
[ 0  3 -1  0 -1]
[ 0 -1  2  0 -1]
[-1  0 -1  2  0]
[ 0 -1 -1  0  2]</pre>
</div>
<p>NOTES:</p>
<p>This is the Laplacian matrix with the row and column indexed by the
sink vertex removed.</p>
</blockquote>
<p>&#8212;</p>
<p id="reorder-vertices"><strong>reorder_vertices()</strong></p>
<blockquote>
<p>Create a copy of the sandpile but with the vertices ordered according
to their distance from the sink, from greatest to least.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Sandpile</p>
<dl class="docutils">
<dt>EXAMPLES::</dt>
<dd><p class="first">sage: S.dict()
{0: {},</p>
<blockquote>
1: {0: 1, 3: 1, 4: 1},
2: {0: 1, 3: 1, 5: 1},
3: {2: 1, 5: 1},
4: {1: 1, 3: 1},
5: {2: 1, 3: 1}}</blockquote>
<p>sage: T = S.reorder_vertices()
sage: T.dict()
{0: {2: 1, 3: 1},</p>
<blockquote class="last">
1: {2: 1, 4: 1},
2: {0: 1, 3: 1},
3: {0: 1, 2: 1, 5: 1},
4: {1: 1, 2: 1, 5: 1},
5: {}}</blockquote>
</dd>
</dl>
</blockquote>
<p>&#8212;</p>
<p id="resolution-verbose"><strong>resolution(verbose)</strong></p>
<blockquote>
<p>This function computes a minimal free resolution of the homogeneous
sandpile ideal.  If <tt class="docutils literal"><span class="pre">verbose</span></tt> is <tt class="xref docutils literal"><span class="pre">True</span></tt>, then all of the mappings
are returned.  Otherwise, the resolution is summarized.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">verbose</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>free resolution of the sandpile ideal</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('gor')
sage: S.resolution()
'R^1 &lt;-- R^5 &lt;-- R^5 &lt;-- R^1'
sage: S.resolution(true)
[[ x1^2 - x3*x0 x3*x1 - x2*x0  x3^2 - x2*x1  x2*x3 - x0^2  x2^2 - x1*x0],
 [ x3  x2   0  x0   0]
[-x1 -x3  x2   0 -x0]
[ x0  x1   0  x2   0]
[  0   0 -x1 -x3  x2]
[  0   0  x0  x1 -x3],
 [ x2^2 - x1*x0]
[-x2*x3 + x0^2]
[-x3^2 + x2*x1]
[x3*x1 - x2*x0]
[ x1^2 - x3*x0]]
sage: r[0]*r[1]
[0 0 0 0 0]
sage: r[1]*r[2]
[0]
[0]
[0]
[0]
[0]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="ring"><strong>ring()</strong></p>
<blockquote>
<p>The ring containing the homogeneous sandpile ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>ring</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.ring()
Multivariate Polynomial Ring in x5, x4, x3, x2, x1, x0 over Rational Field
sage: S.ring().gens()
(x5, x4, x3, x2, x1, x0)</pre>
</div>
<p>NOTES:</p>
<p>The indeterminate <img class="math" src="_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i"/> corresponds to the <img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/>-th vertex as listed my
the method <tt class="docutils literal"><span class="pre">vertices</span></tt>. The term-ordering is degrevlex with
indeterminates ordered according to their distance from the sink (larger
indeterminates are further from the sink).</p>
</blockquote>
<p>&#8212;</p>
<p id="sink"><strong>sink()</strong></p>
<blockquote>
<p>Returns the identifier for the sink vertex.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Object (name for the sink vertex)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: G = sandlib('generic')
sage: G.sink()
0
sage: H = grid(2,2)
sage: H.sink()
'sink'
sage: type(H.sink())
&lt;type 'str'&gt;</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="solve"><strong>solve()</strong></p>
<blockquote>
<p>Computes approximations of the complex affine zeros of the sandpile
ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of complex numbers</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile({0: {}, 1: {2: 2}, 2: {0: 4, 1: 1}}, 0)
sage: S.solve()
[[0.707107*I - 0.707107, 0.707107 - 0.707107*I],
 [-0.707107*I - 0.707107, 0.707107*I + 0.707107],
 [-1*I, -1*I],
 [I, I],
 [0.707107*I + 0.707107, -0.707107*I - 0.707107],
 [0.707107 - 0.707107*I, 0.707107*I - 0.707107],
 [1, 1],
 [-1, -1]]
sage: len(_)
8
sage: S.group_order()
8</pre>
</div>
<p>NOTES:</p>
<p>The solutions form a multiplicative group isomorphic to the sandpile
group.  Generators for this group are given exactly by <tt class="docutils literal"><span class="pre">points()</span></tt>.</p>
</blockquote>
<p>&#8212;</p>
<p id="superstables-verbose"><strong>superstables(verbose)</strong></p>
<blockquote>
<p>Returns the list of superstable configurations as dictionaries if
<tt class="docutils literal"><span class="pre">verbose</span></tt> is <tt class="xref docutils literal"><span class="pre">True</span></tt>, otherwise as lists of integers.  The
superstables are also known as <img class="math" src="_images/math/6e28ce12d49d39f160d5a0ef54077fc98e4b9d2b.png" alt="G"/>-parking functions.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">verbose</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>list (of superstable elements)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.superstables()
[{1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
 {1: 0, 2: 0, 3: 1, 4: 0, 5: 0},
 {1: 2, 2: 0, 3: 0, 4: 0, 5: 1},
 {1: 2, 2: 0, 3: 0, 4: 0, 5: 0},
 {1: 1, 2: 0, 3: 0, 4: 0, 5: 0},
 {1: 1, 2: 0, 3: 1, 4: 0, 5: 0},
 {1: 0, 2: 0, 3: 0, 4: 1, 5: 0},
 {1: 0, 2: 0, 3: 1, 4: 1, 5: 0},
 {1: 0, 2: 0, 3: 0, 4: 1, 5: 1},
 {1: 1, 2: 0, 3: 0, 4: 0, 5: 1},
 {1: 1, 2: 0, 3: 0, 4: 1, 5: 1},
 {1: 1, 2: 0, 3: 0, 4: 1, 5: 0},
 {1: 2, 2: 0, 3: 1, 4: 0, 5: 0},
 {1: 0, 2: 0, 3: 0, 4: 0, 5: 1},
 {1: 1, 2: 0, 3: 1, 4: 1, 5: 0}]
sage: S.superstables(false)
[[0, 0, 0, 0, 0],
 [0, 0, 1, 0, 0],
 [2, 0, 0, 0, 1],
 [2, 0, 0, 0, 0],
 [1, 0, 0, 0, 0],
 [1, 0, 1, 0, 0],
 [0, 0, 0, 1, 0],
 [0, 0, 1, 1, 0],
 [0, 0, 0, 1, 1],
 [1, 0, 0, 0, 1],
 [1, 0, 0, 1, 1],
 [1, 0, 0, 1, 0],
 [2, 0, 1, 0, 0],
 [0, 0, 0, 0, 1],
 [1, 0, 1, 1, 0]]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="symmetric-recurrents-orbits"><strong>symmetric_recurrents(orbits)</strong></p>
<blockquote>
<p>Returns the list of symmetric recurrent configurations.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">orbits</span></tt> - list of lists partitioning the vertices</p>
<p>OUTPUT:</p>
<p>list of recurrent configurations</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('kite')
sage: S.dict()
{0: {},
 1: {0: 1, 2: 1, 3: 1},
 2: {1: 1, 3: 1, 4: 1},
 3: {1: 1, 2: 1, 4: 1},
 4: {2: 1, 3: 1}}
sage: S.symmetric_recurrents([[1],[2,3],[4]])
[{1: 2, 2: 2, 3: 2, 4: 1}, {1: 2, 2: 2, 3: 2, 4: 0}]
sage: S.recurrents()
[{1: 2, 2: 2, 3: 2, 4: 1},
 {1: 2, 2: 2, 3: 2, 4: 0},
 {1: 2, 2: 1, 3: 2, 4: 0},
 {1: 2, 2: 2, 3: 0, 4: 1},
 {1: 2, 2: 0, 3: 2, 4: 1},
 {1: 2, 2: 2, 3: 1, 4: 0},
 {1: 2, 2: 1, 3: 2, 4: 1},
 {1: 2, 2: 2, 3: 1, 4: 1}]</pre>
</div>
<p>NOTES:</p>
<p>The user is responsible for ensuring that the list of orbits comes from
a group of symmetries of the underlying graph.</p>
</blockquote>
<p>&#8212;</p>
<p id="unsaturated-ideal"><strong>unsaturated_ideal()</strong></p>
<blockquote>
<p>The unsaturated, homogeneous sandpile ideal.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>ideal</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.unsaturated_ideal().gens()</pre>
</div>
</blockquote>
<dl class="docutils">
<dt>(x1^3 - x4*x3*x0, x2^3 - x5*x3*x0, x3^2 - x5*x2, x4^2 - x3*x1, x5^2 - x3*x2)</dt>
<dd><p class="first">sage: S.ideal().gens()
(x2 - x0,</p>
<blockquote class="last">
x3^2 - x5*x0,
x5*x3 - x0^2,
x4^2 - x3*x1,
x5^2 - x3*x0,
x1^3 - x4*x3*x0,
x4*x1^2 - x5*x0^2)</blockquote>
</dd>
</dl>
<p>&#8212;</p>
<p id="version"><strong>version()</strong></p>
<blockquote>
<p>Returns the version number of Sage Sandpiles.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>string</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.version()
Sage Sandpiles Version 2.0</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="vertices-boundary-first"><strong>vertices(boundary_first)</strong></p>
<blockquote>
<p>Return a list of the vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">boundary_first</span></tt> - Return the boundary vertices
first.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: P = graphs.PetersenGraph()
sage: P.vertices()
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
</div>
<p>Note that the output of the vertices() function is always sorted.
This is sub-optimal, speed-wise, but note the following
optimizations:</p>
<div class="highlight-python"><pre>sage: timeit V = P.vertices()                     # not tested
100000 loops, best of 3: 8.85 [micro]s per loop
sage: timeit V = list(P.vertex_iterator())        # not tested
100000 loops, best of 3: 5.74 [micro]s per loop
sage: timeit V = list(P._nxg.adj.iterkeys())      # not tested
100000 loops, best of 3: 3.45 [micro]s per loop</pre>
</div>
<p>In other words, if you want a fast vertex iterator, call the
dictionary directly.</p>
</blockquote>
<p>&#8212;</p>
<p id="zero-config"><strong>zero_config()</strong></p>
<blockquote>
<p>The all-zero configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.zero_config()
{1: 0, 2: 0, 3: 0, 4: 0, 5: 0}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="zero-div"><strong>zero_div()</strong></p>
<blockquote>
<p>The all-zero divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.zero_div()
{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0}</pre>
</div>
</blockquote>
</div>
<div class="section" id="config">
<h4>Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h4>
<p><strong>Summary of methods.</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#id9"><em>+</em></a> &#8212; Addition of configurations.</li>
<li><a class="reference internal" href="#id10"><em>&amp;</em></a> &#8212; The stabilization of the sum.</li>
<li><a class="reference internal" href="#id11"><em>~</em></a> &#8212; The stabilized configuration.</li>
<li><a class="reference internal" href="#less-equal"><em>less-equal</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of <tt class="docutils literal"><span class="pre">other</span></tt>.</li>
<li><a class="reference internal" href="#less"><em>less</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of <tt class="docutils literal"><span class="pre">other</span></tt> and the two configurations are not equal.</li>
<li><a class="reference internal" href="#mul"><em>*</em></a> &#8212; The recurrent element equivalent to the sum.</li>
<li><a class="reference internal" href="#pow"><em>^</em></a> &#8212; Exponentiation for *-operator.</li>
<li><a class="reference internal" href="#neg"><em>-</em></a> &#8212; The additive inverse of the configuration.</li>
<li><a class="reference internal" href="#id12"><em>-</em></a> &#8212; Subtraction of configurations.</li>
<li><a class="reference internal" href="#add-random"><em>add_random()</em></a> &#8212; Add one grain of sand to a random nonsink vertex.</li>
<li><a class="reference internal" href="#deg"><em>deg()</em></a> &#8212; The degree of the configuration.</li>
<li><a class="reference internal" href="#dualize"><em>dualize()</em></a> &#8212; The difference between the maximal stable configuration and the configuration.</li>
<li><a class="reference internal" href="#equivalent-recurrent-with-firing-vector"><em>equivalent_recurrent(with_firing_vector)</em></a> &#8212; The equivalent recurrent configuration equivalent.</li>
<li><a class="reference internal" href="#equivalent-superstable-with-firing-vector"><em>equivalent_superstable(with_firing_vector)</em></a> &#8212; The equivalent superstable configuration.</li>
<li><a class="reference internal" href="#fire-script-sigma"><em>fire_script(sigma)</em></a> &#8212; Fire the script <tt class="docutils literal"><span class="pre">sigma</span></tt>, i.e., fire each vertex the indicated number of times.</li>
<li><a class="reference internal" href="#firing-vector-s-d-e"><em>firing_vector(S, D, E)</em></a> &#8212; Firing vector from
divisor <tt class="docutils literal"><span class="pre">D</span></tt> to divisor <tt class="docutils literal"><span class="pre">E</span></tt>.</li>
<li><a class="reference internal" href="#fire-unstable"><em>fire_unstable()</em></a> &#8212; Fire all unstable vertices.</li>
<li><a class="reference internal" href="#fire-vertex-v"><em>fire_vertex(v)</em></a> &#8212; Fire the vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</li>
<li><a class="reference internal" href="#is-recurrent"><em>is_recurrent()</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if the configuration is recurrent.</li>
<li><a class="reference internal" href="#is-stable"><em>is_stable()</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> stable.</li>
<li><a class="reference internal" href="#is-superstable"><em>is_superstable()</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">config</span></tt> is
superstable.</li>
<li><a class="reference internal" href="#is-symmetric-orbits"><em>is_symmetric(orbits)</em></a> &#8212; Is the configuration are constant over the vertices in each sublist of <tt class="docutils literal"><span class="pre">orbits</span></tt>?</li>
<li><a class="reference internal" href="#order"><em>order()</em></a> &#8212; The order of the recurrent element equivalent to <tt class="docutils literal"><span class="pre">config</span></tt>.</li>
<li><a class="reference internal" href="#stabilize-with-firing-vector"><em>stabilize(with_firing_vector)</em></a> &#8212; The stabilized configuration and optionally returns the corresponding firing vector.</li>
<li><a class="reference internal" href="#support"><em>support()</em></a> &#8212; Keys of the nonzero values of the dictionary.</li>
<li><a class="reference internal" href="#unstable"><em>unstable()</em></a> &#8212; List of the unstable vertices.</li>
<li><a class="reference internal" href="#values"><em>values()</em></a> &#8212; The values of the configuration as a list.</li>
</ul>
<hr class="docutils" />
<p><strong>Complete descriptions of Config methods.</strong></p>
<p id="id9"><strong>+</strong></p>
<blockquote>
<p>Defines addition of configurations.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>sum of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: d = Config(S, [3,2])
sage: c + d
{1: 4, 2: 4}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="id10"><strong>&amp;</strong></p>
<blockquote>
<p>Returns the stabilization of the sum.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c + c  # ordinary addition
{1: 2, 2: 0, 3: 0}
sage: c &amp; c  # add and stabilize
{1: 0, 2: 1, 3: 0}
sage: c*c  # add and find equivalent recurrent
{1: 1, 2: 1, 3: 1}
sage: ~(c + c) == c &amp; c
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="id11"><strong>~</strong></p>
<blockquote>
<p>Returns the stabilized configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">Config</span></tt></p>
<p>Returns the stabilized configuration.
EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: c = S.max_stable() + S.identity()
sage: ~c
{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}
sage: ~c == c.stabilize()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="less-equal"><strong>&lt;=</strong></p>
<blockquote>
<p>Returns true if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of
<tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: d = Config(S, [2,3])
sage: e = Config(S, [2,0])
sage: c &lt;= c
True
sage: c &lt;= d
True
sage: d &lt;= c
False
sage: c &lt;= e
False
sage: e &lt;= c
False</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="less"><strong>&lt;</strong></p>
<blockquote>
<p>Returns true if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that
of <tt class="docutils literal"><span class="pre">other</span></tt> and the two configurations are not equal.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: d = Config(S, [2,3])
sage: c &lt; c
False
sage: c &lt; d
True
sage: d &lt; c
False</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="mul"><strong>*</strong></p>
<blockquote>
<p>Returns the recurrent element equivalent to the sum.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c + c  # ordinary addition
{1: 2, 2: 0, 3: 0}
sage: c &amp; c  # add and stabilize
{1: 0, 2: 1, 3: 0}
sage: c*c  # add and find equivalent recurrent
{1: 1, 2: 1, 3: 1}
sage: (c*c).is_recurrent()
True
sage: c*(-c) == S.identity()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="pow"><strong>^</strong></p>
<blockquote>
<p>Returns the recurrent element equivalent to the sum of the
configuration with itself <tt class="docutils literal"><span class="pre">k</span></tt> times.  If <tt class="docutils literal"><span class="pre">k</span></tt> is negative, do the
same for the negation of the configuration.  If <tt class="docutils literal"><span class="pre">k</span></tt> is zero, return
the identity of the sandpile group.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">k</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c = Config(S, [1,0,0])
sage: c^3
{1: 1, 2: 1, 3: 0}
sage: (c + c + c) == c^3
False
sage: (c + c + c).equivalent_recurrent() == c^3
True
sage: c^(-1)
{1: 1, 2: 1, 3: 0}
sage: c^0 == S.identity()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="neg"><strong>-</strong></p>
<blockquote>
<p>The additive inverse of the configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: -c
{1: -1, 2: -2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="id12"><strong>-</strong></p>
<blockquote>
<p>Defines subtraction of configurations.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Config</p>
<p>OUTPUT:</p>
<p>sum of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: d = Config(S, [3,2])
sage: c - d
{1: -2, 2: 0}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="add-random"><strong>add_random()</strong></p>
<blockquote>
<p>Add one grain of sand to a random nonsink vertex.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<p>We compute the &#8216;sizes&#8217; of the avalanches caused by adding random grains
of sand to the maximal stable configuration on a grid graph.  The
function <tt class="docutils literal"><span class="pre">stabilize()</span></tt> returns the firing vector of the
stabilization, a dictionary whose values say how many times each vertex
fires in the stabilization.</p>
<div class="highlight-python"><pre>sage: S = grid(10,10)
sage: m = S.max_stable()
sage: a = []
sage: for i in range(1000):
...       m = m.add_random()
...       m, f = m.stabilize(true)
...       a.append(sum(f.values()))
...
sage: p = list_plot([[log(i+1),log(a.count(i))] for i in [0..max(a)] if a.count(i)])
sage: p.axes_labels(['log(N)','log(D(N))'])
sage: t = text("Distribution of avalanche sizes", (2,2), rgbcolor=(1,0,0))
sage: show(p+t,axes_labels=['log(N)','log(D(N))'])</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="deg"><strong>deg()</strong></p>
<blockquote>
<p>Returns the degree of the configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>integer</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: c.deg()
3</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="dualize"><strong>dualize()</strong></p>
<blockquote>
<p>Returns the difference between the maximal stable configuration and the
configuration.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: S.max_stable()
{1: 1, 2: 1}
sage: c.dualize()
{1: 0, 2: -1}
sage: S.max_stable() - c == c.dualize()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="equivalent-recurrent-with-firing-vector"><strong>equivalent_recurrent(with_firing_vector)</strong></p>
<blockquote>
<p>Returns the recurrent configuration equivalent to the given
configuration and optionally returns the corresponding firing vector.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">with_firing_vector</span></tt> (optional) -  boolean</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">Config</span></tt> or <tt class="docutils literal"><span class="pre">[Config,</span> <span class="pre">firing_vector]</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: c = Config(S, [0,0,0,0,0])
sage: c.equivalent_recurrent() == S.identity()
True
sage: x = c.equivalent_recurrent(true)
sage: r = vector([x[0][v] for v in S.nonsink_vertices()])
sage: f = vector([x[1][v] for v in S.nonsink_vertices()])
sage: cv = vector(c.values())
sage: r == cv - f*S.reduced_laplacian()
True</pre>
</div>
<p>NOTES:</p>
<p>Let <img class="math" src="_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> be the reduced laplacian, <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> the initial configuration, <img class="math" src="_images/math/b55ca7a0aa88ab7d58f4fc035317fdac39b17861.png" alt="r"/> the
returned configuration, and <img class="math" src="_images/math/bb2c93730dbb48558bb3c4738c956c4e8f816437.png" alt="f"/> the firing vector.  Then <img class="math" src="_images/math/4b669d00df0312122a018e2b058aa3472a05e759.png" alt="r = c - f *
L"/>.</p>
</blockquote>
<p>&#8212;</p>
<p id="equivalent-superstable-with-firing-vector"><strong>equivalent_superstable(with_firing_vector)</strong></p>
<blockquote>
<p>Returns the equivalent superstable configuration and optionally
returns the corresponding firing vector.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">with_firing_vector</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">Config</span></tt> or <tt class="docutils literal"><span class="pre">[Config,</span> <span class="pre">firing_vector]</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: m = S.max_stable()
sage: m.equivalent_superstable().is_superstable()
True
sage: x = m.equivalent_superstable(true)
sage: s = vector(x[0].values())
sage: f = vector(x[1].values())
sage: mv = vector(m.values())
sage: s == mv - f*S.reduced_laplacian()
True</pre>
</div>
<p>NOTES:</p>
<p>Let <img class="math" src="_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> be the reduced laplacian, <img class="math" src="_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> the initial configuration, <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> the
returned configuration, and <img class="math" src="_images/math/bb2c93730dbb48558bb3c4738c956c4e8f816437.png" alt="f"/> the firing vector.  Then <img class="math" src="_images/math/ba8200e4fde4090442431246314e18798bef71d8.png" alt="s = c - f *
L"/>.</p>
</blockquote>
<p>&#8212;</p>
<p id="fire-script-sigma"><strong>fire_script(sigma)</strong></p>
<blockquote>
<p>Fire the script <tt class="docutils literal"><span class="pre">sigma</span></tt>, i.e., fire each vertex the indicated number
of times.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span></tt> - Config or (list or dict representing a Config)</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c = Config(S, [1,2,3])
sage: c.unstable()
[2, 3]
sage: c.fire_script(Config(S,[0,1,1]))
{1: 2, 2: 1, 3: 2}
sage: c.fire_script(Config(S,[2,0,0])) == c.fire_vertex(1).fire_vertex(1)
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="fire-unstable"><strong>fire_unstable()</strong></p>
<blockquote>
<p>Fire all unstable vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c = Config(S, [1,2,3])
sage: c.fire_unstable()
{1: 2, 2: 1, 3: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="fire-vertex-v"><strong>fire_vertex(v)</strong></p>
<blockquote>
<p>Fire the vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">v</span></tt> - vertex</p>
<p>OUTPUT:</p>
<p>Config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: c = Config(S, [1,2])
sage: c.fire_vertex(2)
{1: 2, 2: 0}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-recurrent"><strong>is_recurrent()</strong></p>
<blockquote>
<p>Returns True if the configuration is recurrent.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.identity().is_recurrent()
True
sage: S.zero_config().is_recurrent()
False</pre>
</div>
</blockquote>
<p id="is-stable"><strong>is_stable()</strong></p>
<blockquote>
<p>Returns True stable.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.max_stable().is_stable()
True
sage: (S.max_stable() + S.max_stable()).is_stable()
False
sage: (S.max_stable() &amp; S.max_stable()).is_stable()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-superstable"><strong>is_superstable()</strong></p>
<blockquote>
<p>Returns True if <tt class="docutils literal"><span class="pre">config</span></tt> is superstable, i.e., whether its dual is
recurrent.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.zero_config().is_superstable()
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-symmetric-orbits"><strong>is_symmetric(orbits)</strong></p>
<blockquote>
<p>This function checks if the values of the configuration are constant
over the vertices in each sublist of <tt class="docutils literal"><span class="pre">orbits</span></tt>.</p>
<p>INPUT:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">orbits</span></tt> - list of lists of vertices</blockquote>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('kite')
sage: S.dict()
{0: {},
 1: {0: 1, 2: 1, 3: 1},
 2: {1: 1, 3: 1, 4: 1},
 3: {1: 1, 2: 1, 4: 1},
 4: {2: 1, 3: 1}}
sage: c = Config(S, [1, 2, 2, 3])
sage: c.is_symmetric([[2,3]])
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="order"><strong>order()</strong></p>
<blockquote>
<p>Returns the order of the recurrent element equivalent to <tt class="docutils literal"><span class="pre">config</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - configuration</p>
<p>OUTPUT:</p>
<p>integer</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: [r.order() for r in S.recurrents()]
[3, 3, 5, 15, 15, 15, 5, 15, 15, 5, 15, 5, 15, 1, 15]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="stabilize-with-firing-vector"><strong>stabilize(with_firing_vector)</strong></p>
<blockquote>
<p>Returns the stabilized configuration and optionally returns the
corresponding firing vector.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">with_firing_vector</span></tt> (optional) -  boolean</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">Config</span></tt> or <tt class="docutils literal"><span class="pre">[Config,</span> <span class="pre">firing_vector]</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: c = S.max_stable() + S.identity()
sage: c.stabilize(true)
[{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}, {1: 1, 2: 5, 3: 7, 4: 1, 5: 6}]
sage: S.max_stable() &amp; S.identity()
{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}
sage: S.max_stable() &amp; S.identity() == c.stabilize()
True
sage: ~c
{1: 2, 2: 2, 3: 1, 4: 1, 5: 1}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="support"><strong>support()</strong></p>
<blockquote>
<p>The input is a dictionary of integers.  The output is a list of keys
of nonzero values of the dictionary.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list - support of the config</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: c = S.identity()
sage: c.values()
[2, 2, 1, 1, 0]
sage: c.support()
[1, 2, 3, 4]
sage: S.vertices()
[0, 1, 2, 3, 4, 5]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="unstable"><strong>unstable()</strong></p>
<blockquote>
<p>List of the unstable vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of vertices</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: c = Config(S, [1,2,3])
sage: c.unstable()
[2, 3]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="values"><strong>values()</strong></p>
<blockquote>
<p>Return the values of the configuration as a list, sorted in the order
of the vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of integers</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile({'a':[1,'b'], 'b':[1,'a'], 1:['a']},'a')
sage: c = Config(S, {'b':1, 1:2})
sage: c
{1: 2, 'b': 1}
sage: c.values()
[2, 1]
sage: S.nonsink_vertices()
[1, 'b']</pre>
</div>
</blockquote>
</div>
<div class="section" id="divisor">
<h4>Divisor<a class="headerlink" href="#divisor" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#id13"><em>+</em></a> &#8212; Defines addition of divisors.</li>
<li><a class="reference internal" href="#less-equal-divisor"><em>less-equal</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of <tt class="docutils literal"><span class="pre">other</span></tt>.</li>
<li><a class="reference internal" href="#less-divisor"><em>less</em></a> &#8212; <tt class="xref docutils literal"><span class="pre">True</span></tt> if every component
of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of <tt class="docutils literal"><span class="pre">other</span></tt> and the two divisors are not
equal.</li>
<li><a class="reference internal" href="#neg-divisor"><em>-</em></a> &#8212; The additive inverse of the divisor.</li>
<li><a class="reference internal" href="#sub-divisor"><em>-</em></a> &#8212; Subtraction of divisors.</li>
<li><a class="reference internal" href="#add-random-divisor"><em>add_random()</em></a> &#8212; Add one grain of sand to a random vertex.</li>
<li><a class="reference internal" href="#betti"><em>betti()</em></a> &#8212; The Betti numbers for the simplicial complex
associated with the divisor.</li>
<li><a class="reference internal" href="#deg-divisor"><em>deg()</em></a> &#8212; The degree of the divisor.</li>
<li><a class="reference internal" href="#dcomplex"><em>Dcomplex()</em></a> &#8212; The simplicial complex determined
by the supports of the linearly equivalent effective divisors.</li>
<li><a class="reference internal" href="#dualize-divisor"><em>dualize()</em></a> &#8212; The difference between the maximal
stable divisor and the divisor.</li>
<li><a class="reference internal" href="#effective-div"><em>effective_div()</em></a> &#8212; All linearly equivalent effective divisors.</li>
<li><a class="reference internal" href="#fire-script-sigma-divisor"><em>fire_script(sigma)</em></a> &#8212; Fire the script <tt class="docutils literal"><span class="pre">sigma</span></tt>, i.e., fire each vertex the indicated number of times.</li>
<li><a class="reference internal" href="#fire-unstable-divisor"><em>fire_unstable()</em></a> &#8212; Fire all unstable vertices.</li>
<li><a class="reference internal" href="#fire-vertex-v-divisor"><em>fire_vertex(v)</em></a> &#8212; Fire the vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</li>
<li><a class="reference internal" href="#is-alive-cycle"><em>is_alive(cycle)</em></a> &#8212; Will the divisor stabilize under
repeated firings of all unstable vertices?</li>
<li><a class="reference internal" href="#is-symmetric-orbits-divisor"><em>is_symmetric(orbits)</em></a> &#8212; Is the configuration are constant over the vertices in each sublist of <tt class="docutils literal"><span class="pre">orbits</span></tt>?</li>
<li><a class="reference internal" href="#linear-system"><em>linear_system()</em></a> &#8212; The complete linear system of a divisor.</li>
<li><a class="reference internal" href="#r-of-d-verbose"><em>r_of_D(verbose)</em></a> &#8212; Returns <tt class="docutils literal"><span class="pre">r(D)</span></tt> and,
optionally, an effective divisor <tt class="docutils literal"><span class="pre">F</span></tt> such that <tt class="docutils literal"><span class="pre">|D</span> <span class="pre">-</span> <span class="pre">F|</span></tt> is empty.</li>
<li><a class="reference internal" href="#support-divisor"><em>support()</em></a> &#8212; List of keys of the nonzero values of the divisor.</li>
<li><a class="reference internal" href="#unstable-divisor"><em>unstable()</em></a> &#8212; List of the unstable vertices.</li>
<li><a class="reference internal" href="#values-divisor"><em>values()</em></a> &#8212; The values of the divisor as a list,
sorted in the order of the vertices.</li>
</ul>
<hr class="docutils" />
<p><strong>Complete descriptions of Divisor methods.</strong></p>
<p id="id13"><strong>+</strong></p>
<blockquote>
<p>Defines addition of divisors.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Divisor</p>
<p>OUTPUT:</p>
<p>sum of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: E = Divisor(S, [3,2,1])
sage: D + E
{0: 4, 1: 4, 2: 4}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="less-equal-divisor"><strong>&lt;=</strong></p>
<blockquote>
<p>Returns true if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that of
<tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Divisor</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: E = Divisor(S, [2,3,4])
sage: F = Divisor(S, [2,0,4])
sage: D &lt;= D
True
sage: D &lt;= E
True
sage: E &lt;= D
False
sage: D &lt;= F
False
sage: F &lt;= D
False</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="less-divisor"><strong>&lt;</strong></p>
<blockquote>
<p>Returns true if every component of <tt class="docutils literal"><span class="pre">self</span></tt> is at most that
of <tt class="docutils literal"><span class="pre">other</span></tt> and the two divisors are not equal.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Divisor</p>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: E = Divisor(S, [2,3,4])
sage: D &lt; D
False
sage: D &lt; E
True
sage: E &lt; D
False</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="neg-divisor"><strong>-</strong></p>
<blockquote>
<p>The additive inverse of the divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: -D
{0: -1, 1: -2, 2: -3}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="sub-divisor"><strong>-</strong></p>
<blockquote>
<p>Defines subtraction of divisors.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">other</span></tt> - Divisor</p>
<p>OUTPUT:</p>
<p>sum of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: E = Divisor(S, [3,2,1])
sage: D - E
{0: -2, 1: 0, 2: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="add-random-divisor"><strong>add_random()</strong></p>
<blockquote>
<p>Add one grain of sand to a random vertex.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: S.zero_div().add_random()  #random
{0: 0, 1: 0, 2: 0, 3: 1, 4: 0, 5: 0}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="betti"><strong>betti()</strong></p>
<blockquote>
<p>Returns the Betti numbers for the simplicial complex associated with
the divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>dictionary of integers</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [2,0,1])
sage: D.betti()
{0: 0, 1: 1}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="dcomplex"><strong>Dcomplex()</strong></p>
<blockquote>
<p>Returns the simplicial complex determined by the supports of the
linearly equivalent effective divisors.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>simplicial complex</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: p = Divisor(S, [0,1,2,0,0,1]).Dcomplex()
sage: p.homology()
{0: 0, 1: Z x Z, 2: 0, 3: 0}
sage: p.f_vector()
[1, 6, 15, 9, 1]
sage: p.betti()
{0: 0, 1: 2, 2: 0, 3: 0}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="deg-divisor"><strong>deg()</strong></p>
<blockquote>
<p>Returns the degree of the divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>integer</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.deg()
6</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="dualize-divisor"><strong>dualize()</strong></p>
<blockquote>
<p>Returns the difference between the maximal stable divisor and the
divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<dl class="docutils">
<dt>EXAMPLES::</dt>
<dd>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.dualize()
{0: 0, 1: -1, 2: -2}
sage: S.max_stable_div() - D == D.dualize()
True</dd>
</dl>
</blockquote>
<p>&#8212;</p>
<p id="effective-div"><strong>effective_div()</strong></p>
<blockquote>
<p>Returns all linearly equivalent effective divisors.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list (of divisors)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: D = Divisor(S, [0,0,0,0,0,2])
sage: D.effective_div()
[{0: 1, 1: 0, 2: 0, 3: 1, 4: 0, 5: 0},
 {0: 0, 1: 0, 2: 1, 3: 1, 4: 0, 5: 0},
 {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 2}]
sage: [d.values() for d in _]
[[1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 2]]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="fire-script-sigma-divisor"><strong>fire_script(sigma)</strong></p>
<blockquote>
<p>Fire the script <tt class="docutils literal"><span class="pre">sigma</span></tt>, i.e., fire each vertex the indicated number
of times.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span></tt> - Divisor or (list or dict representing a Divisor)</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.unstable()
[1, 2]
sage: D.fire_script([0,1,1])
{0: 3, 1: 1, 2: 2}
sage: D.fire_script(Divisor(S,[2,0,0])) == D.fire_vertex(0).fire_vertex(0)
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="fire-unstable-divisor"><strong>fire_unstable()</strong></p>
<blockquote>
<p>Fire all unstable vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.fire_unstable()
{0: 3, 1: 1, 2: 2}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="fire-vertex-v-divisor"><strong>fire_vertex(v)</strong></p>
<blockquote>
<p>Fire the vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">v</span></tt> - vertex</p>
<p>OUTPUT:</p>
<p>Divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.fire_vertex(1)
{0: 2, 1: 0, 2: 4}</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-alive-cycle"><strong>is_alive(cycle)</strong></p>
<blockquote>
<p>Will the divisor stabilize under repeated firings of all unstable
vertices?  Optionally returns the resulting cycle.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">cycle</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>boolean or optionally, a list of Divisors</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = complete_sandpile(4)
sage: D = Divisor(S, {0: 4, 1: 3, 2: 3, 3: 2})
sage: D.is_alive()
True
sage: D.is_alive(true)
[{0: 4, 1: 3, 2: 3, 3: 2}, {0: 3, 1: 2, 2: 2, 3: 5}, {0: 1, 1: 4, 2: 4, 3: 3}]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="is-symmetric-orbits-divisor"><strong>is_symmetric(orbits)</strong></p>
<blockquote>
<p>This function checks if the values of the divisor are constant
over the vertices in each sublist of <tt class="docutils literal"><span class="pre">orbits</span></tt>.</p>
<p>INPUT:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">orbits</span></tt> - list of lists of vertices</li>
</ul>
</blockquote>
<p>OUTPUT:</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('kite')
sage: S.dict()
{0: {},
 1: {0: 1, 2: 1, 3: 1},
 2: {1: 1, 3: 1, 4: 1},
 3: {1: 1, 2: 1, 4: 1},
 4: {2: 1, 3: 1}}
sage: D = Divisor(S, [2,1, 2, 2, 3])
sage: D.is_symmetric([[0,2,3]])
True</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="linear-system"><strong>linear_system()</strong></p>
<blockquote>
<p>Returns the complete linear system of a divisor.</p>
<p>INPUT: None</p>
<p>OUTPUT:</p>
<p>dict - <tt class="docutils literal"><span class="pre">{num_homog:</span> <span class="pre">int,</span> <span class="pre">homog:list,</span> <span class="pre">num_inhomog:int,</span> <span class="pre">inhomog:list}</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: D = Divisor(S, [0,0,0,0,0,2])
sage: D.linear_system()
{'homog': [[-1, -1, -1], [1, 1, 1]],
 'inhomog': [[1, 0, 0], [0, -1, -1], [0, 0, 0]],
 'num_homog': 2,
 'num_inhomog': 3}</pre>
</div>
<p>NOTES:</p>
<p>If <img class="math" src="_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> is the Laplacian, an arbitrary <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> such that <img class="math" src="_images/math/061e720179b13bc5cd152449068e5c0dc01fb50a.png" alt="v * L&gt;= -D"/>
has the form <img class="math" src="_images/math/659c94ca072c3ed83faf323bdfc82564d9de7a41.png" alt="v = w + t"/> where <img class="math" src="_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/> is in <tt class="docutils literal"><span class="pre">inhomg</span></tt> and <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/> is in the
integer span of <tt class="docutils literal"><span class="pre">homog</span></tt> in the output of <tt class="docutils literal"><span class="pre">linear_system(D)</span></tt>.</p>
<p>WARNING:</p>
<p>This method requires 4ti2.  After local installation of 4ti2, set the
<tt class="docutils literal"><span class="pre">path_to_zsolve</span></tt> at the beginning of <tt class="docutils literal"><span class="pre">sandpile.sage</span></tt>.</p>
</blockquote>
<p>&#8212;</p>
<p id="r-of-d-verbose"><strong>r_of_D(verbose)</strong></p>
<blockquote>
<p>Returns <tt class="docutils literal"><span class="pre">r(D)</span></tt> and, if <tt class="docutils literal"><span class="pre">verbose</span></tt> is <tt class="docutils literal"><span class="pre">True,</span> <span class="pre">an</span> <span class="pre">effective</span> <span class="pre">divisor</span>
<span class="pre">``F</span></tt> such that <tt class="docutils literal"><span class="pre">|D</span> <span class="pre">-</span> <span class="pre">F|</span></tt> is empty.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">verbose</span></tt> (optional) - boolean</p>
<p>OUTPUT:</p>
<p>integer <tt class="docutils literal"><span class="pre">r(D)</span></tt> or tuple (integer <tt class="docutils literal"><span class="pre">r(D)</span></tt>, divisor <tt class="docutils literal"><span class="pre">F</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: D = Divisor(S, [0,0,0,0,0,4])
sage: E = D.r_of_D(true)
sage: E
(1, {0: 0, 1: 1, 2: 0, 3: 1, 4: 0, 5: 0})
sage: F = E[1]
sage: (D - F).values()
[0, -1, 0, -1, 0, 4]
sage: (D - F).effective_div()
[]
sage: Divisor(S, [0,0,0,0,0,-4]).r_of_D(true)
(-1, {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: -4})</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="support-divisor"><strong>support()</strong></p>
<blockquote>
<p>List of keys of the nonzero values of the divisor.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list - support of the divisor</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = sandlib('generic')
sage: c = S.identity()
sage: c.values()
[2, 2, 1, 1, 0]
sage: c.support()
[1, 2, 3, 4]
sage: S.vertices()
[0, 1, 2, 3, 4, 5]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="unstable-divisor"><strong>unstable()</strong></p>
<blockquote>
<p>List of the unstable vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of vertices</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(3), 0)
sage: D = Divisor(S, [1,2,3])
sage: D.unstable()
[1, 2]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="values-divisor"><strong>values()</strong></p>
<blockquote>
<p>Return the values of the divisor as a list, sorted in the order of the
vertices.</p>
<p>INPUT:</p>
<p>None</p>
<p>OUTPUT:</p>
<p>list of integers</p>
<p>boolean</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile({'a':[1,'b'], 'b':[1,'a'], 1:['a']},'a')
sage: D = Divisor(S, {'a':0, 'b':1, 1:2})
sage: D
{1: 2, 'a': 0, 'b': 1}
sage: D.values()
[2, 0, 1]
sage: S.vertices()
[1, 'a', 'b']</pre>
</div>
</blockquote>
</div>
<div class="section" id="other">
<h4>Other<a class="headerlink" href="#other" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#admissible-partitions-s-k"><em>admissible_partitions(S, k)</em></a> &#8212;
Partitions of the vertices into <tt class="docutils literal"><span class="pre">k</span></tt> parts, each of which is connected.</li>
<li><a class="reference internal" href="#aztec-n"><em>aztec(n)</em></a> &#8212; The aztec diamond graph.</li>
<li><a class="reference internal" href="#complete-sandpile-n"><em>complete_sandpile(n)</em></a> &#8212; Sandpile on the complete graph.</li>
<li><a class="reference internal" href="#firing-graph-s-eff"><em>firing_graph(S, eff)</em></a> &#8212; The
firing graph.</li>
<li><a class="reference internal" href="#firing-vector-s-d-e"><em>firing_vector(S, D, E)</em></a> &#8212; The firing vector
taking divisor <tt class="docutils literal"><span class="pre">D</span></tt> to divisor <tt class="docutils literal"><span class="pre">E</span></tt>.</li>
<li><a class="reference internal" href="#glue-graphs-g-h-glue-g-glue-h"><em>glue_graphs(g, h, glue_g, glue_h)</em></a> &#8212; Glue two sandpiles
together.</li>
<li><a class="reference internal" href="#grid-m-n"><em>grid(m, n)</em></a> &#8212; The <img class="math" src="_images/math/520df6c71065c91174d0ed0d562ebd3c5980267f.png" alt="m\times n"/> grid sandpile.</li>
<li><a class="reference internal" href="#min-cycles-g-v"><em>min_cycles(G, v)</em></a> &#8212; The minimal length cycles in
the digraph <tt class="docutils literal"><span class="pre">G</span></tt> starting at vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</li>
<li><a class="reference internal" href="#parallel-firing-graph-s-eff"><em>parallel_firing_graph(S, eff)</em></a> &#8212; The
parallel-firing graph.</li>
<li><a class="reference internal" href="#partition-sandpile-s-p"><em>partition_sandpile(S, p)</em></a> &#8212; Sandpile formed
with vertices consisting of parts of an admissible partition.</li>
<li><a class="reference internal" href="#random-graph-num-verts-p-directed-weight-max"><em>random_graph(num_verts, p, directed, weight_max)</em></a> &#8212; A
random graph.</li>
<li><a class="reference internal" href="#random-dag-num-verts-p-weight-max"><em>random_DAG(num_verts, p, weight_max)</em></a> &#8212; A random directed acyclic graph.</li>
<li><a class="reference internal" href="#random-tree-n-d"><em>random_tree(n, d)</em></a> &#8212; Random tree sandpile.</li>
<li><a class="reference internal" href="#sandlib-selector"><em>sandlib(selector)</em></a> &#8212; A collection of sandpiles.</li>
<li><a class="reference internal" href="#triangle-n"><em>triangle(n)</em></a> &#8212; The triangle sandpile.</li>
<li><a class="reference internal" href="#wilmes-algorithm-m"><em>wilmes_algorithm(M)</em></a> &#8212; Find matrix with the
same integer row span as <tt class="docutils literal"><span class="pre">M</span></tt> that is the reduced Laplacian of a digraph.</li>
</ul>
<hr class="docutils" />
<p><strong>Complete descriptions of methods.</strong></p>
<p id="admissible-partitions-s-k"><strong>admissible_partitions(S, k)</strong></p>
<blockquote>
<p>The partitions of the vertices of <tt class="docutils literal"><span class="pre">S</span></tt> into <tt class="docutils literal"><span class="pre">k</span></tt> parts,
each of which is connected.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">S</span></tt> - Sandpile
<tt class="docutils literal"><span class="pre">k</span></tt> - integer</p>
<p>OUTPUT:</p>
<p>list of partitions</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: P = [admissible_partitions(S, i) for i in [2,3,4]]
sage: P
[[{{1, 2, 3}, {0}},
  {{0, 2, 3}, {1}},
  {{2}, {0, 1, 3}},
  {{0, 1, 2}, {3}},
  {{2, 3}, {0, 1}},
  {{1, 2}, {0, 3}}],
 [{{2, 3}, {0}, {1}},
  {{1, 2}, {3}, {0}},
  {{2}, {0, 3}, {1}},
  {{2}, {3}, {0, 1}}],
 [{{2}, {3}, {0}, {1}}]]
sage: for p in P:
...    sum([partition_sandpile(S, i).betti(verbose=false)[-1] for i in p])
6
8
3
sage: S.betti()
           0     1     2     3
------------------------------
    0:     1     -     -     -
    1:     -     6     8     3
------------------------------
total:     1     6     8     3</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="aztec-n"><strong>aztec(n)</strong></p>
<blockquote>
<p>The aztec diamond graph.</p>
<p>INPUT:</p>
<p>n - integer</p>
<p>OUTPUT:</p>
<p>dictionary for the aztec diamond graph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: aztec(2)

{(-3/2, -1/2): {},
 (-3/2, 1/2): {},
 (-1/2, -3/2): {'sink': 2, (-1/2, -1/2): 1, (1/2, -3/2): 1},
 (-1/2, -1/2): {(-3/2, -1/2): 1,
                (-1/2, -3/2): 1,
                (-1/2, 1/2): 1,
                (1/2, -1/2): 1},
 (-1/2, 1/2): {(-3/2, 1/2): 1, (-1/2, -1/2): 1, (-1/2, 3/2): 1, (1/2, 1/2): 1},
 (-1/2, 3/2): {},
 (1/2, -3/2): {},
 (1/2, -1/2): {(-1/2, -1/2): 1, (1/2, -3/2): 1, (1/2, 1/2): 1, (3/2, -1/2): 1},
 (1/2, 1/2): {(-1/2, 1/2): 1, (1/2, -1/2): 1, (1/2, 3/2): 1, (3/2, 1/2): 1},
 (1/2, 3/2): {},
 (3/2, -1/2): {},
 (3/2, 1/2): {}}
sage: Sandpile(aztec(2),'sink').group_order()
4542720</pre>
</div>
<p>NOTES:</p>
<p>This is the aztec diamond graph with a sink vertex added.  Boundary
vertices have edges to the sink so that each vertex has degree 4.</p>
</blockquote>
<p>&#8212;</p>
<p id="complete-sandpile-n"><strong>complete_sandpile(n)</strong></p>
<blockquote>
<p>The sandpile on the complete graph with n vertices.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">n</span></tt> - positive integer</p>
<p>OUTPUT:</p>
<p>Sandpile</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: K = complete_sandpile(5)
sage: K.betti(verbose=False)
[1, 15, 50, 60, 24]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="firing-graph-s-eff"><strong>firing_graph(S, eff)</strong></p>
<blockquote>
<p>Creates a digraph with divisors as vertices and edges between two
divisors <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">E</span></tt> if firing a single vertex in <tt class="docutils literal"><span class="pre">D</span></tt> gives
<tt class="docutils literal"><span class="pre">E</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">S</span></tt> - sandpile
<tt class="docutils literal"><span class="pre">eff</span></tt> - list of divisors</p>
<p>OUTPUT:</p>
<p>DiGraph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(6),0)
sage: D = Divisor(S, [1,1,1,1,2,0])
sage: eff = D.effective_div()
sage: firing_graph(S,eff).show3d(edge_size=.005,vertex_size=0.01)</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="firing-vector-s-d-e"><strong>firing_vector(S, D, E)</strong></p>
<blockquote>
<p>If <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">E</span></tt> are linearly equivalent divisors, find the firing vector
taking <tt class="docutils literal"><span class="pre">D</span></tt> to <tt class="docutils literal"><span class="pre">E</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">S</span></tt> -Sandpile</li>
</ul>
<p><tt class="docutils literal"><span class="pre">D</span></tt>, <tt class="docutils literal"><span class="pre">E</span></tt> - tuples (representing linearly equivalent divisors)</p>
<p>OUTPUT:</p>
<p>tuple (representing a firing vector from <tt class="docutils literal"><span class="pre">D</span></tt> to <tt class="docutils literal"><span class="pre">E</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = complete_sandpile(4)
sage: D = Divisor(S, {0: 0, 1: 0, 2: 8, 3: 0})
sage: E = Divisor(S, {0: 2, 1: 2, 2: 2, 3: 2})
sage: v = firing_vector(S, D, E)
sage:
sage: v
(0, 0, 2, 0)</pre>
</div>
<p>The divisors must be linearly equivalent:</p>
<div class="highlight-python"><pre>sage: vector(D.values()) - S.laplacian()*vector(v) == vector(E.values())
True
sage: firing_vector(S, D, S.zero_div())
Error. Are the divisors linearly equivalent?</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="glue-graphs-g-h-glue-g-glue-h"><strong>glue_graphs(g, h, glue_g, glue_h)</strong></p>
<blockquote>
<p>Glue two graphs together.</p>
<p>INPUT:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt>, <tt class="docutils literal"><span class="pre">h</span></tt> - dictionaries for directed multigraphs</li>
<li><tt class="docutils literal"><span class="pre">glue_h</span></tt>, <tt class="docutils literal"><span class="pre">glue_g</span></tt> - dictionaries for a vertex</li>
</ul>
</blockquote>
<p>OUTPUT:</p>
<p>dictionary for a directed multigraph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: x = {0: {}, 1: {0: 1}, 2: {0: 1, 1: 1}, 3: {0: 1, 1: 1, 2: 1}}
sage: y = {0: {}, 1: {0: 2}, 2: {1: 2}, 3: {0: 1, 2: 1}}
sage: glue_x = {1: 1, 3: 2}
sage: glue_y = {0: 1, 1: 2, 3: 1}
sage: z = glue_graphs(x,y,glue_x,glue_y)
sage: z

{0: {},
 'x0': {0: 1, 'x1': 1, 'x3': 2, 'y1': 2, 'y3': 1},
 'x1': {'x0': 1},
 'x2': {'x0': 1, 'x1': 1},
 'x3': {'x0': 1, 'x1': 1, 'x2': 1},
 'y1': {0: 2},
 'y2': {'y1': 2},
 'y3': {0: 1, 'y2': 1}}
sage: S = Sandpile(z,0)
sage: S.first_diffs_hilb()
[1, 6, 17, 31, 41, 41, 31, 17, 6, 1]
sage: S.resolution()
'R &lt;-- R^7 &lt;-- R^21 &lt;-- R^35 &lt;-- R^35 &lt;-- R^21 &lt;-- R^7 &lt;-- R^1'</pre>
</div>
<p>NOTES:</p>
<p>This method makes a dictionary for a graph by combining those for <tt class="docutils literal"><span class="pre">g</span></tt> and
<tt class="docutils literal"><span class="pre">h</span></tt>.  The sink of <tt class="docutils literal"><span class="pre">g</span></tt> is replaced by a vertex that is connected to the
vertices of <tt class="docutils literal"><span class="pre">g</span></tt> as specified by <tt class="docutils literal"><span class="pre">glue_g</span></tt> the vertices of <tt class="docutils literal"><span class="pre">h</span></tt> as
specified in <tt class="docutils literal"><span class="pre">glue_h</span></tt>.  The sink of the glued graph is <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/>.</p>
<p>Both <tt class="docutils literal"><span class="pre">glue_g</span></tt> and <tt class="docutils literal"><span class="pre">glue_h</span></tt> are dictionaries with entries of the form
<tt class="docutils literal"><span class="pre">v:w</span></tt> where <tt class="docutils literal"><span class="pre">v</span></tt> is the vertex to be connected to and <tt class="docutils literal"><span class="pre">w</span></tt> is the weight
of the connecting edge.</p>
</blockquote>
<p>&#8212;</p>
<p id="grid-m-n"><strong>grid(m, n)</strong></p>
<blockquote>
<p>The mxn grid sandpile.  Each nonsink vertex has degree 4.</p>
<p>INPUT:
<tt class="docutils literal"><span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">n</span></tt> - positive integers</p>
<p>OUTPUT:
dictionary for a sandpile with sink named <tt class="docutils literal"><span class="pre">sink</span></tt>.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><pre>sage: grid(3,4)
{'sink': {},
(1, 1): {'sink': 2, (1, 2): 1, (2, 1): 1},
(1, 2): {'sink': 1, (1, 1): 1, (1, 3): 1, (2, 2): 1},
(1, 3): {'sink': 1, (1, 2): 1, (1, 4): 1, (2, 3): 1},
(1, 4): {'sink': 2, (1, 3): 1, (2, 4): 1},
(2, 1): {'sink': 1, (1, 1): 1, (2, 2): 1, (3, 1): 1},
(2, 2): {(1, 2): 1, (2, 1): 1, (2, 3): 1, (3, 2): 1},
(2, 3): {(1, 3): 1, (2, 2): 1, (2, 4): 1, (3, 3): 1},
(2, 4): {'sink': 1, (1, 4): 1, (2, 3): 1, (3, 4): 1},
(3, 1): {'sink': 2, (2, 1): 1, (3, 2): 1},
(3, 2): {'sink': 1, (2, 2): 1, (3, 1): 1, (3, 3): 1},
(3, 3): {'sink': 1, (2, 3): 1, (3, 2): 1, (3, 4): 1},
(3, 4): {'sink': 2, (2, 4): 1, (3, 3): 1}}
sage: S = Sandpile(grid(3,4),'sink')
sage: S.group_order()
4140081</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="min-cycles-g-v"><strong>min_cycles(G, v)</strong></p>
<blockquote>
<p>Minimal length cycles in the digraph <tt class="docutils literal"><span class="pre">G</span></tt> starting at vertex <tt class="docutils literal"><span class="pre">v</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">G</span></tt> - DiGraph
<tt class="docutils literal"><span class="pre">v</span></tt> - vertex of <tt class="docutils literal"><span class="pre">G</span></tt></p>
<p>OUTPUT:</p>
<p>list of lists of vertices</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: T = sandlib('gor')
sage: [min_cycles(T, i) for i in T.vertices()]
[[], [[1, 3]], [[2, 3, 1], [2, 3]], [[3, 1], [3, 2]]]</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="parallel-firing-graph-s-eff"><strong>parallel_firing_graph(S, eff)</strong></p>
<blockquote>
<p>Creates a digraph with divisors as vertices and edges between two
divisors <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">E</span></tt> if firing all unstable vertices in <tt class="docutils literal"><span class="pre">D</span></tt> gives
<tt class="docutils literal"><span class="pre">E</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">S</span></tt> - Sandpile
<tt class="docutils literal"><span class="pre">eff</span></tt> - list of divisors</p>
<p>OUTPUT:</p>
<p>DiGraph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(6),0)
sage: D = Divisor(S, [1,1,1,1,2,0])
sage: eff = D.effective_div()
sage: parallel_firing_graph(S,eff).show3d(edge_size=.005,vertex_size=0.01)</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="partition-sandpile-s-p"><strong>partition_sandpile(S, p)</strong></p>
<blockquote>
<p>Each set of vertices in <tt class="docutils literal"><span class="pre">p</span></tt> is regarded as a single vertex, with and edge
between <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> if some element of <tt class="docutils literal"><span class="pre">A</span></tt> is connected by an edge
to  some element of <tt class="docutils literal"><span class="pre">B</span></tt> in <tt class="docutils literal"><span class="pre">S</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">S</span></tt> - Sandpile
<tt class="docutils literal"><span class="pre">p</span></tt> - partition of the vertices of <tt class="docutils literal"><span class="pre">S</span></tt></p>
<p>OUTPUT:</p>
<p>Sandpile</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = Sandpile(graphs.CycleGraph(4), 0)
sage: P = [admissible_partitions(S, i) for i in [2,3,4]]
sage: for p in P:
sum([partition_sandpile(S, i).betti(verbose=false)[-1] for i in p])
6
8
3
sage: S.betti()
           0     1     2     3
------------------------------
    0:     1     -     -     -
    1:     -     6     8     3
------------------------------
total:     1     6     8     3</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="random-graph-num-verts-p-directed-weight-max"><strong>random_graph(num_verts, p=1/2, directed=True, weight_max=1)</strong></p>
<blockquote>
<p>A random weighted digraph with a directed spanning tree rooted at <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/>.  If
<tt class="docutils literal"><span class="pre">directed</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the only difference is that if <img class="math" src="_images/math/1be32ce5760195be477a19d96f1f3a18c9e026ea.png" alt="(i,j,w)"/> is an edge with
tail <img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/>, head <img class="math" src="_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j"/>, and weight <img class="math" src="_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/>, then <img class="math" src="_images/math/32c6f13ddb30b37953e7e4327a5d5e16e401eaae.png" alt="(j,i,w)"/> appears also.  The result
is returned as a Sage digraph.</p>
<p>INPUT:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">num_verts</span></tt> - number of vertices</li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - probability edges occur</li>
<li><tt class="docutils literal"><span class="pre">directed</span></tt> - True if directed</li>
<li><tt class="docutils literal"><span class="pre">weight_max</span></tt> - integer maximum for random weights</li>
</ul>
</blockquote>
<p>OUTPUT:</p>
<p>random graph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: g = random_graph(6,0.2,True,3)
sage: S = Sandpile(g,0)
sage: S.show(edge_labels = True)</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="random-dag-num-verts-p-weight-max"><strong>random_DAG(num_verts, p=1/2, weight_max=1)</strong></p>
<blockquote>
<p>Returns a random directed acyclic graph with <tt class="docutils literal"><span class="pre">num_verts</span></tt> vertices.
The method starts with the sink vertex and adds vertices one at a time.
Each vertex is connected only to only previously defined vertices, and the
probability of each possible connection is given by the argument <tt class="docutils literal"><span class="pre">p</span></tt>.
The weight of an edge is a random integer between <tt class="docutils literal"><span class="pre">1</span></tt> and
<tt class="docutils literal"><span class="pre">weight_max</span></tt>.</p>
<p>INPUT:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">num_verts</span></tt> - positive integer</li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - number between <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/> and <img class="math" src="_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1"/></li>
<li><tt class="docutils literal"><span class="pre">weight_max</span></tt> &#8211; integer greater than <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/></li>
</ul>
</blockquote>
<p>OUTPUT:</p>
<p>directed acyclic graph with sink <img class="math" src="_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0"/></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: S = random_DAG(5, 0.3)</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="random-tree-n-d"><strong>random_tree(n, d)</strong></p>
<blockquote>
<p>Returns a random undirected tree with <tt class="docutils literal"><span class="pre">n</span></tt> nodes, no node having
degree higher than <tt class="docutils literal"><span class="pre">d</span></tt>.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">n</span></tt>, <tt class="docutils literal"><span class="pre">d</span></tt> - integers</p>
<p>OUTPUT:</p>
<p>Graph</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: T = random_tree(15,3)
sage: T.show()
sage: S = Sandpile(T,0)
sage: U = S.reorder_vertices()
sage: Graph(U).show()</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="sandlib-selector"><strong>sandlib(selector=None)</strong></p>
<blockquote>
<p>Returns the sandpile identified by <tt class="docutils literal"><span class="pre">selector</span></tt>.  If no argument is
given, a description of the sandpiles in the sandlib is printed.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">selector</span></tt> - identifier or None</p>
<p>OUTPUT:</p>
<p>sandpile or description</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: sandlib()

  Sandpiles in the sandlib:
     kite : generic undirected graphs with 5 vertices
     generic : generic digraph with 6 vertices
     ci1 : complete intersection, non-DAG but equivalent to a DAG
     riemann-roch1 : directed graph with postulation 9 and 3 maximal weight superstables
     riemann-roch2 : directed graph with a superstable not majorized by a maximal superstable
     gor : Gorenstein but not a complete intersection

sage: S = sandlib('gor')
sage: S.resolution()
'R &lt;-- R^5 &lt;-- R^5 &lt;-- R^1'</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="triangle-n"><strong>triangle(n)</strong></p>
<blockquote>
<p>A triangular sandpile.  Each nonsink vertex has out-degree six.  The
vertices on the boundary of the triangle are connected to the sink.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">n</span></tt> - int</p>
<p>OUTPUT:</p>
<p>Sandpile</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: T = triangle(5)
sage: T.group_order()
135418115000</pre>
</div>
</blockquote>
<p>&#8212;</p>
<p id="wilmes-algorithm-m"><strong>wilmes_algorithm(M)</strong></p>
<blockquote>
<p>Computes an integer matrix <tt class="docutils literal"><span class="pre">L</span></tt> with the same integer row span as <tt class="docutils literal"><span class="pre">M</span></tt>
and such that <tt class="docutils literal"><span class="pre">L</span></tt> is the reduced laplacian of a directed multigraph.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">M</span></tt> - square integer matrix of full rank</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">L</span></tt> - integer matrix</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><pre>sage: P = matrix([[2,3,-7,-3],[5,2,-5,5],[8,2,5,4],[-5,-9,6,6]])
sage: wilmes_algorithm(P)

[ 1642   -13 -1627    -1]
[   -1  1980 -1582  -397]
[    0    -1  1650 -1649]
[    0     0 -1658  1658]</pre>
</div>
<p>NOTES:</p>
<p>The algorithm is due to John Wilmes.</p>
</blockquote>
</div>
</div>
<div class="section" id="help">
<h3>Help<a class="headerlink" href="#help" title="Permalink to this headline">¶</a></h3>
<p>Documentation for each method is available through the Sage online help system:</p>
<div class="highlight-python"><pre>sage: Config.fire_vertex?
Base Class:     &lt;type 'instancemethod'&gt;
String Form:    &lt;unbound method Config.fire_vertex&gt;
Namespace:      Interactive
File:           /home/davidp/.sage/temp/xyzzy/20445/_home_davidp_math_sandpile_sage_sage_sandpile2_0_sandpile_sage_697.py
Definition:     Config.fire_vertex(self, v)
Docstring:

    Fire the vertex ``v``.

    INPUT:

    ``v`` - vertex

    OUTPUT:

    Config

    EXAMPLES::

        sage: S = Sandpile(graphs.CycleGraph(3), 0)
        sage: c = Config(S, [1,2])
        sage: c.fire_vertex(2)
        {1: 2, 2: 0}</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An alternative to <tt class="docutils literal"><span class="pre">Config.fire_vertex?</span></tt> in the preceding code example
would be <tt class="docutils literal"><span class="pre">c.fire_vertex?</span></tt>, if <tt class="docutils literal"><span class="pre">c</span></tt> is any Config.</p>
</div>
<p>General Sage documentation can be found at <a class="reference external" href="http://sagemath.org/doc/">http://sagemath.org/doc/</a>.</p>
</div>
</div>
<div class="section" id="contact">
<h2>Contact<a class="headerlink" href="#contact" title="Permalink to this headline">¶</a></h2>
<p>Please contact <a class="reference external" href="mailto:davidp&#37;&#52;&#48;reed&#46;edu">davidp<span>&#64;</span>reed<span>&#46;</span>edu</a> with questions, bug reports, and suggestions for
additional features and other improvements.</p>
<table class="docutils citation" frame="void" id="bn" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BN]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Matthew Baker, Serguei Norine, <a class="reference external" href="http://people.math.gatech.edu/~mbaker/papers.html">Riemann-Roch and Abel-Jacobi Theory on a Finite Graph</a>, Advances in Mathematics 215 (2007), 766&#8211;788.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="btw" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[BTW]</a></td><td>Per Bak, Chao Tang and Kurt Wiesenfeld (1987). <em>Self-organized criticality: an explanation of 1/ƒ noise</em>, Physical Review Letters 60: 381–384 <a class="reference external" href="http://en.wikipedia.org/wiki/Bak-Tang-Wiesenfeld_sandpile">Wikipedia article</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="crs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[CRS]</a></td><td>Robert Cori, Dominique Rossin, and Bruno Salvy, <em>Polynomial ideals for sandpiles and their Gröbner bases</em>, Theoretical Computer Science, 276 (2002) no. 1&#8211;2, 1&#8211;15.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="h" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[H]</a></td><td>Holroyd, Levine, Meszaros, Peres, Propp, Wilson, <a class="reference external" href="http://front.math.ucdavis.edu/0801.3306">Chip-Firing and Rotor-Routing on Directed Graphs</a>. The final version of this paper appears in <em>In and out of Equilibrium II</em>, Eds. V. Sidoravicius, M. E. Vares, in the Series Progress in Probability, Birkhauser (2008).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ppw" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[PPW]</a></td><td>David Perkinson, Jacob Perlman, and John Wilmes, <em>Primer for the algebraic geometry of sandpile groups</em>, preprint (2009).</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Welcome to Sage Sandpiles&#8217;s documentation!</a><ul>
<li><a class="reference external" href="#introduction">Introduction</a><ul>
<li><a class="reference external" href="#configurations-and-divisors">Configurations and divisors</a></li>
<li><a class="reference external" href="#stabilization">Stabilization</a></li>
<li><a class="reference external" href="#laplacian">Laplacian</a></li>
<li><a class="reference external" href="#recurrent-elements">Recurrent elements</a></li>
<li><a class="reference external" href="#burning-configuration">Burning Configuration</a></li>
<li><a class="reference external" href="#sandpile-group">Sandpile group</a></li>
<li><a class="reference external" href="#self-organized-criticality">Self-organized criticality</a></li>
<li><a class="reference external" href="#divisors-and-discrete-riemann-surfaces">Divisors and Discrete Riemann surfaces</a><ul>
<li><a class="reference external" href="#riemann-roch">Riemann-Roch</a></li>
<li><a class="reference external" href="#picturing-linear-systems">Picturing linear systems</a></li>
</ul>
</li>
<li><a class="reference external" href="#algebraic-geometry-of-sandpiles">Algebraic geometry of sandpiles</a><ul>
<li><a class="reference external" href="#affine">Affine</a></li>
<li><a class="reference external" href="#projective">Projective</a></li>
<li><a class="reference external" href="#zeros">Zeros</a></li>
<li><a class="reference external" href="#resolutions">Resolutions</a></li>
<li><a class="reference external" href="#complete-intersections-and-arithmetically-gorenstein-toppling-ideals">Complete Intersections and Arithmetically Gorenstein toppling ideals</a></li>
<li><a class="reference external" href="#betti-numbers-for-undirected-graphs">Betti numbers for undirected graphs</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference external" href="#installation">Installation</a></li>
<li><a class="reference external" href="#usage">Usage</a><ul>
<li><a class="reference external" href="#initialization">Initialization</a></li>
<li><a class="reference external" href="#methods">Methods</a><ul>
<li><a class="reference external" href="#sandpile">Sandpile</a></li>
<li><a class="reference external" href="#config">Config</a></li>
<li><a class="reference external" href="#divisor">Divisor</a></li>
<li><a class="reference external" href="#other">Other</a></li>
</ul>
</li>
<li><a class="reference external" href="#help">Help</a></li>
</ul>
</li>
<li><a class="reference external" href="#contact">Contact</a></li>
</ul>
</li>
</ul>

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/sandpile.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="">Sage Sandpiles v2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, David Perkinson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
    </div>
  </body>
</html>